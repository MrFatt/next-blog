<!DOCTYPE html><html style="height:100%" class="jsx-3241352696"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">Next-blog</title><link rel="preload" href="/_next/static/wWB~SiLn_g9IuIhvDzML9/pages/post.js" as="script"/><link rel="preload" href="/_next/static/wWB~SiLn_g9IuIhvDzML9/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/wWB~SiLn_g9IuIhvDzML9/pages/_error.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-7d4c186a3aecb0bb5bf3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.588b470a21a58a43c7dc.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-3f3666d0dcad119f41d5.js" as="script"/><style id="__jsx-3241352696">div#__next{height:100%;}</style><style id="__jsx-821146791">a.jsx-821146791{margin-right:30px;font-size:20px;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;color:rgba(0,0,0,0.7);}</style><style id="__jsx-1769670723">header.jsx-1769670723{box-shadow:0 0 1px rgba(0,0,0,0.2);-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;}
.header-container.jsx-1769670723{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:0 auto;padding-top:20px;max-width:1000px;padding-bottom:20px;}
div.slogan.jsx-1769670723{display:inline-block;font-weight:bold;font-size:24px;font-family:"Oswald",sans-serif;}
a.jsx-1769670723{-webkit-text-decoration:none;text-decoration:none;cursor:pointer;color:rgba(0,0,0,0.7);}</style><style id="__jsx-3564541774">img{max-width:900px;}
blockquote{padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;margin-left:0;margin-bottom:16px;margin-top:0;}
p,li{word-wrap:break-word;font-size:18px;line-height:1.58;-webkit-letter-spacing:-0.003em;-moz-letter-spacing:-0.003em;-ms-letter-spacing:-0.003em;letter-spacing:-0.003em;}
p>code{padding:0.2em 0.4em;margin:0;font-size:85%;border-radius:3px;font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo, Courier,monospace;}
pre{margin-top:0;margin-bottom:0;}
pre>code{font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo, Courier,monospace;line-height:1.45;}</style><style id="__jsx-1732950521">.footer-container.jsx-1732950521{height:40px;margin-top:40px;background-color:black;}
.footer-content.jsx-1732950521{color:white;max-width:1000px;font-family:"Oswald",sans-serif;margin:10px auto;line-height:1.5;}
a.jsx-1732950521{margin-left:5px;color:white;}</style><style id="__jsx-2994019239">.jsx-2994019239{font-family:"Open Sans","Roboto","Microsoft YaHei","微软雅黑",STXihei, "华文细黑",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:auto;}
.content-container.jsx-2994019239{margin-top:50;-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}
.content.jsx-2994019239{margin:0 auto;max-width:1000px;height:100%;min-height:650px;}</style><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans:300,400,500" class="jsx-3241352696"/><link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet" class="jsx-3241352696"/><link href="/static/dracula.css" rel="stylesheet" class="jsx-3241352696"/><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" class="jsx-3241352696"></script><script class="jsx-3241352696">hljs.initHighlightingOnLoad();</script></head><body style="height:100%;margin:0" class="jsx-3241352696"><div id="__next"><div class="jsx-2994019239"><header class="jsx-1769670723"><div class="jsx-1769670723 header-container"><div class="jsx-1769670723 slogan"><a class="jsx-1769670723" href="/">Star Boy</a></div><div class="jsx-821146791"><a class="jsx-821146791" href="/">Home</a><a class="jsx-821146791" href="/about/">About</a></div></div></header><div class="jsx-2994019239 content-container"><div class="jsx-2994019239 content"><div class="jsx-3564541774"><h1>[翻译]Airbnb 的 React Native 实践： 移动端发展计划</h1>
<blockquote>
<p>整装待发,重回原生</p>
</blockquote>
<p><em>这是我们介绍 React Native 经验和 Airbnb mobile 未来计划<a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c">系列博客</a>的第五篇</em></p>
<h2>激动人心的时刻即将来临</h2>
<p>虽然在使用 React Native 开发,但是我们也一直在积累原生开发的经验.现在我们已经一系列正在进行中或已完成的项目.其中,部分项目是受到 React Native 经验和最佳实践的启发而完成的.</p>
<h3>服务器端渲染</h3>
<p>尽管不再使用 React Native, 我们仍然十分重视只写一次产品代码的价值. 我们仍然高度依赖我们的统一设计语言系统, 使许多 Android 和 iOS 的页面看起来完全一样.</p>
<p>许多团队已经尝试了强大的服务器端渲染的框架,并且达成一致.在这些框架中,服务器将描述组件渲染,页面配置和相关操作的信息发送给移动设备.不同的移动平台获取到数据后使用 DLS 组件渲染原生页面或者整个流程.</p>
<p>大规模服务器端渲染也存在着一些挑战. 下面是我们正在解决的一些问题:</p>
<ul>
<li>安全升级组件定义的同时维护向下兼容性.</li>
<li>跨平台共享组件的类型定义.</li>
<li>在运行时的事件响应,如点击按钮或用户输入</li>
<li>多个 JSON 驱动页面间跳转的同时,维护内部状态.</li>
<li>构建时没有实现的自定义组件的渲染.我们正在尝试使用<a href="https://github.com/airbnb/Lona/">Lona</a>解决.</li>
</ul>
<p>服务器端渲染框架使我们能够更方便的进行试验以及热更新,为我们提供了巨大的价值.</p>
<h3>Epoxy 组件</h3>
<p>在 2016 年,我们开源了 Android 的<a href="https://github.com/airbnb/epoxy">Epoxy</a>.Epoxy 可以实现简单的异构<code>RecyclerViews</code>, <code>UICollectionViews</code>和<code>UITableviews</code>. 如今大多数的新页面都使用 Epoxy. 这使得我们可以将每个页面分解成独立的组件,进而实现懒加载. 而且在 iOS 和 Android 上均可使用.
iOS 端示例代码:</p>
<pre><code class="language-swift"><span class="hljs-type">BasicRow</span>.epoxyModel(
  content: <span class="hljs-type">BasicRow</span>.<span class="hljs-type">Content</span>(
    titleText: <span class="hljs-string">"Settings"</span>,
    subtitleText: <span class="hljs-string">"Optional subtitle"</span>),
  style: .standard,
  dataID: <span class="hljs-string">"settings"</span>,
  selectionHandler: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-number">_</span>, <span class="hljs-number">_</span>, <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">self</span>?.navigate(to: .settings)
  })
</code></pre>
<p>在 Android 上,我们利用<a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">DSLs in Kotlin</a>,使得组件的实现变得简单而且类型安全:</p>
<pre><code class="language-kotlin">basicRow {
 id(<span class="hljs-string">"settings"</span>)
 title(R.string.settings)
 subtitleText(R.string.settings_subtitle)
 onClickListener { navigateTo(SETTINGS) }
}
</code></pre>
<h3>Epoxy 中的 diffing</h3>
<p>在 React 中,<a href="https://reactjs.org/tutorial/tutorial.html#what-is-react">render</a>会返回一个组件的列表.React 性能的关键是组件仅仅是真实 DOM 的数据模型.对组件树进行 diff,然后只更新改动部分.我们在 Epoxy 中引入了相似的概念.在 Epoxy 中,在<a href="https://reactjs.org/tutorial/tutorial.html#what-is-react">buildModels</a>中声明整个页面的模型,再加上 Kotlin DSL,使得它在概念上与 React 十分相似,示例代码:</p>
<pre><code class="language-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> EpoxyController.<span class="hljs-title">buildModels</span><span class="hljs-params">()</span></span> {
  header {
    id(<span class="hljs-string">"marquee"</span>)
    title(R.string.edit_profile)
  }
  inputRow {
    id(<span class="hljs-string">"first name"</span>)
    title(R.string.first_name)
    text(firstName)
    onChange {
      firstName = it
      requestModelBuild()
    }
  }
  <span class="hljs-comment">// 其余的模型放在这里</span>
}
</code></pre>
<p>每当你的数据发生变化,调用<code>requestModelBuild()</code>将会调用最佳的<code>RecyclerView</code>来重新渲染你的页面.</p>
<p>iOS 端的示例代码:</p>
<pre><code class="language-swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">itemModel</span><span class="hljs-params">(forDataID dataID: DemoDataID)</span></span> -&gt; <span class="hljs-type">EpoxyableModel</span>? {
  <span class="hljs-keyword">switch</span> dataID {
  <span class="hljs-keyword">case</span> .header:
    <span class="hljs-keyword">return</span> <span class="hljs-type">DocumentMarquee</span>.epoxyModel(
      content: <span class="hljs-type">DocumentMarquee</span>.<span class="hljs-type">Content</span>(titleText: <span class="hljs-string">"Edit Profile"</span>),
      style: .standard,
      dataID: <span class="hljs-type">DemoDataID</span>.header)
  <span class="hljs-keyword">case</span> .inputRow:
    <span class="hljs-keyword">return</span> <span class="hljs-type">InputRow</span>.epoxyModel(
      content: <span class="hljs-type">InputRow</span>.<span class="hljs-type">Content</span>(
        titleText: <span class="hljs-string">"First name"</span>,
        inputText: firstName)
      style: .standard,
      dataID: <span class="hljs-type">DemoDataID</span>.inputRow,
      behaviorSetter: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] view, content, dataID <span class="hljs-keyword">in</span>
        view.textDidChangeBlock = { <span class="hljs-number">_</span>, inputText <span class="hljs-keyword">in</span>
          <span class="hljs-keyword">self</span>?.firstName = inputText
          <span class="hljs-keyword">self</span>?.rebuildItemModel(forDataID: .inputRow)
        }
      })
  }
}
</code></pre>
<h3>一个全新的 Android 产品框架(MvRx)</h3>
<p>在近期开发中,最令人兴奋的是一个正在开发的新框架,我们内部叫做 MvRx.MvRx 结合了<code>Epoxy</code>,<a href="https://developer.android.com/jetpack/"><code>Jetpack</code></a>,<a href="https://github.com/ReactiveX/RxJava"><code>RxJava</code></a>和<code>Kotlin</code>的优点,以及一些 React 中的规则,使得构建新页面变得更加简单,更加流畅.它是由常见的开发模式以及 React 中的优点开发的,是一个&quot;固定&quot;(<a href="https://stackoverflow.com/questions/802050/what-is-opinionated-software">opinionated</a>)但灵活的框架.它也是线程安全的，几乎所有东西都不在主线程运行，这使得滚动和动画感觉流畅.</p>
<p>到目前为止,它已经应用到了大量的页面中,并且几乎完全不需要处理生命周期.我们目前正在一些 Android 产品上进行试验,并且如果一切顺利的话会将他开源.下面是创建一个发出网络请求的功能页面所需的全部代码:</p>
<pre><code class="language-Kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleDemoState</span></span>(<span class="hljs-keyword">val</span> listing: Async&lt;Listing&gt; = Uninitialized)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleDemoViewModel</span></span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> initialState: SimpleDemoState) : MvRxViewModel&lt;SimpleDemoState&gt;() {
    init {
        fetchListing()
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchListing</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// This automatically fires off a request and maps its response to Async&lt;Listing&gt;</span>
        <span class="hljs-comment">// which is a sealed class and can be: Unitialized, Loading, Success, and Fail.</span>
        <span class="hljs-comment">// No need for separate success and failure handlers!</span>
        <span class="hljs-comment">// This request is also lifecycle-aware. It will survive configuration changes and</span>
        <span class="hljs-comment">// will never be delivered after onStop.</span>
        ListingRequest.forListingId(<span class="hljs-number">12345</span>L).execute { copy(listing = it) }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleDemoFragment</span> : <span class="hljs-type">MvRxFragment</span></span>() {
    <span class="hljs-comment">// This will automatically subscribe to the ViewModel state and rebuild the epoxy models</span>
    <span class="hljs-comment">// any time anything changes. Similar to how React's render method runs for every change of</span>
    <span class="hljs-comment">// props or state.</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel <span class="hljs-keyword">by</span> fragmentViewModel(SimpleDemoViewModel::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> EpoxyController.<span class="hljs-title">buildModels</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> (state) = withState(viewModel)
        <span class="hljs-keyword">if</span> (state.listing <span class="hljs-keyword">is</span> Loading) {
            loader()
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-comment">// These Epoxy models are not the views themself so calling buildModels is cheap. RecyclerView</span>
        <span class="hljs-comment">// diffing will be automaticaly done and only the models that changed will re-render.</span>
        documentMarquee {
            title(state.listing().name)
        }
        <span class="hljs-comment">// Put the rest of your Epoxy models here...</span>
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> EpoxyController.<span class="hljs-title">buildFooter</span><span class="hljs-params">()</span></span> = fixedActionFooter {
        <span class="hljs-keyword">val</span> (state) = withState(viewModel)
        buttonLoading(state <span class="hljs-keyword">is</span> Loading)
        buttonText(state.listing().price)
        buttonOnClickListener { _ -&gt; }
    }
}
</code></pre>
<p>MvRx 具有简单的构造,用于处理 Fragment 参数,跨进程重启时<code>savedInstanceState</code>的持久化,TTI 追踪以及一些其他的功能.</p>
<p>我们也正在开发一个相似的 iOS 框架,该框架目前正处于早期测试阶段.</p>
<p>尽管我们已经对目前所取得的进展十分满意了,还是希望很快可以听到更多相关的消息.</p>
<h3>迭代速度</h3>
<p>当从 React Native 切换回原生时,迭代速度是显而易见的问题.测试改动的时间从原本只需要 1~2 秒,变成可能需要等待将近 15 分钟是不可接受的.幸运的是,我们能够从一些方面缓解这一现象.</p>
<p>我们在 Android 和 iOS 上构建的基础设施能够根据功能模块编译启动器和部分 app.</p>
<p>在 Android 端使用了<a href="https://developer.android.com/studio/build/build-variants#product-flavors">gradle 产品风格</a>, 我们的 gradle 模块如下图所示:</p>
<p><img src="/static/gradle%20modules.png" alt=""></p>
<p>新的间接层使得工程师可以 app 的切片上进行开发.再配合<a href="https://blog.jetbrains.com/idea/2017/06/intellij-idea-2017-2-eap-introduces-unloaded-modules/">Intellij module unloadinig</a>,可以在 Macbook Pro 上动态提高构建和 IDE 的性能.</p>
<p>我们已经构建了用于创建新的测试 flavor 的脚本,并且在短短几个越能,我们已经完成了超过 20 个.使用这些新风格可以使开发构建提速 2.5 倍,并且超过 5 分钟的比例下降了 15 倍.</p>
<p>作为参考,这是用于动态生成具有根依赖性模块产品风格的<a href="https://gist.github.com/gpeal/d68e4fc1357ef9d126f25afd9ab4eee2">gradle 代码块</a>.</p>
<p>相似地,iOS 上的模块如下图所示:</p>
<p><img src="/static/iOS%20modules.png" alt=""></p>
<p>同样系统的构建速度会提升 3-8 倍.</p>
<h2>结论</h2>
<p>很高兴能够成为一家不怕尝试新技术但又努力保持高质量,高速度和开发体验的公司.最后,React Native 是发布功能,为我们提供了新的移动开发思路的重要工具.如果这听起来像是您想参与的旅程，<a href="https://www.airbnb.com/careers/departments/engineering">请告诉我们</a>！</p>
<p><em>这是 Airbnb 关于 React Native 经验分享和移动端未来计划系列文章的第五篇.</em></p>
<p><a href="./react-native-at-airbnb-1">第一篇: React Native at Airbnb</a></p>
<p><a href="./react-native-at-airbnb-2">第二篇: The Technology</a></p>
<p><a href="./react-native-at-airbnb-3">第三篇: Building a Cross-Platform Mobile Team</a></p>
<p><a href="./react-native-at-airbnb-4">第四篇: Making a Decision on React Native</a></p>
<p><a href="./react-native-at-airbnb-5">第五篇: What’s Next for Mobile</a></p>
<ul>
<li>原文地址：<a href="https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab">https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab</a></li>
<li>译文出自：TWNTF</li>
<li>译者：Yingjian Li</li>
</ul>
</div></div></div><footer style="flex:0 0 auto" class="jsx-1732950521"><div class="jsx-1732950521 footer-container"><div class="jsx-1732950521 footer-content">© 2018 Yingjian Li. Powered by:<a href="https://nextjs.org/" class="jsx-1732950521">Next.js</a>. Inspired by<a href="https://github.com/frostfan/hexo-theme-polarbear" class="jsx-1732950521">Polar Bear</a></div></div></footer></div></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"content":"| date       | tag          |\n| ---------- | ------------ |\n| 2018-08-11 | React-Native |\n\n---\n\n# [翻译]Airbnb 的 React Native 实践： 移动端发展计划\n\n\u003e 整装待发,重回原生\n\n_这是我们介绍 React Native 经验和 Airbnb mobile 未来计划[系列博客](https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c)的第五篇_\n\n## 激动人心的时刻即将来临\n\n虽然在使用 React Native 开发,但是我们也一直在积累原生开发的经验.现在我们已经一系列正在进行中或已完成的项目.其中,部分项目是受到 React Native 经验和最佳实践的启发而完成的.\n\n### 服务器端渲染\n\n尽管不再使用 React Native, 我们仍然十分重视只写一次产品代码的价值. 我们仍然高度依赖我们的统一设计语言系统, 使许多 Android 和 iOS 的页面看起来完全一样.\n\n许多团队已经尝试了强大的服务器端渲染的框架,并且达成一致.在这些框架中,服务器将描述组件渲染,页面配置和相关操作的信息发送给移动设备.不同的移动平台获取到数据后使用 DLS 组件渲染原生页面或者整个流程.\n\n大规模服务器端渲染也存在着一些挑战. 下面是我们正在解决的一些问题:\n\n- 安全升级组件定义的同时维护向下兼容性.\n- 跨平台共享组件的类型定义.\n- 在运行时的事件响应,如点击按钮或用户输入\n- 多个 JSON 驱动页面间跳转的同时,维护内部状态.\n- 构建时没有实现的自定义组件的渲染.我们正在尝试使用[Lona](https://github.com/airbnb/Lona/)解决.\n\n服务器端渲染框架使我们能够更方便的进行试验以及热更新,为我们提供了巨大的价值.\n\n### Epoxy 组件\n\n在 2016 年,我们开源了 Android 的[Epoxy](https://github.com/airbnb/epoxy).Epoxy 可以实现简单的异构`RecyclerViews`, `UICollectionViews`和`UITableviews`. 如今大多数的新页面都使用 Epoxy. 这使得我们可以将每个页面分解成独立的组件,进而实现懒加载. 而且在 iOS 和 Android 上均可使用.\niOS 端示例代码:\n\n```swift\nBasicRow.epoxyModel(\n  content: BasicRow.Content(\n    titleText: \"Settings\",\n    subtitleText: \"Optional subtitle\"),\n  style: .standard,\n  dataID: \"settings\",\n  selectionHandler: { [weak self] _, _, _ in\n    self?.navigate(to: .settings)\n  })\n```\n\n在 Android 上,我们利用[DSLs in Kotlin](https://kotlinlang.org/docs/reference/type-safe-builders.html),使得组件的实现变得简单而且类型安全:\n\n```kotlin\nbasicRow {\n id(\"settings\")\n title(R.string.settings)\n subtitleText(R.string.settings_subtitle)\n onClickListener { navigateTo(SETTINGS) }\n}\n```\n\n### Epoxy 中的 diffing\n\n在 React 中,[render](https://reactjs.org/tutorial/tutorial.html#what-is-react)会返回一个组件的列表.React 性能的关键是组件仅仅是真实 DOM 的数据模型.对组件树进行 diff,然后只更新改动部分.我们在 Epoxy 中引入了相似的概念.在 Epoxy 中,在[buildModels](https://reactjs.org/tutorial/tutorial.html#what-is-react)中声明整个页面的模型,再加上 Kotlin DSL,使得它在概念上与 React 十分相似,示例代码:\n\n```kotlin\noverride fun EpoxyController.buildModels() {\n  header {\n    id(\"marquee\")\n    title(R.string.edit_profile)\n  }\n  inputRow {\n    id(\"first name\")\n    title(R.string.first_name)\n    text(firstName)\n    onChange {\n      firstName = it\n      requestModelBuild()\n    }\n  }\n  // 其余的模型放在这里\n}\n```\n\n每当你的数据发生变化,调用`requestModelBuild()`将会调用最佳的`RecyclerView`来重新渲染你的页面.\n\niOS 端的示例代码:\n\n```swift\noverride func itemModel(forDataID dataID: DemoDataID) -\u003e EpoxyableModel? {\n  switch dataID {\n  case .header:\n    return DocumentMarquee.epoxyModel(\n      content: DocumentMarquee.Content(titleText: \"Edit Profile\"),\n      style: .standard,\n      dataID: DemoDataID.header)\n  case .inputRow:\n    return InputRow.epoxyModel(\n      content: InputRow.Content(\n        titleText: \"First name\",\n        inputText: firstName)\n      style: .standard,\n      dataID: DemoDataID.inputRow,\n      behaviorSetter: { [weak self] view, content, dataID in\n        view.textDidChangeBlock = { _, inputText in\n          self?.firstName = inputText\n          self?.rebuildItemModel(forDataID: .inputRow)\n        }\n      })\n  }\n}\n```\n\n### 一个全新的 Android 产品框架(MvRx)\n\n在近期开发中,最令人兴奋的是一个正在开发的新框架,我们内部叫做 MvRx.MvRx 结合了`Epoxy`,[`Jetpack`](https://developer.android.com/jetpack/),[`RxJava`](https://github.com/ReactiveX/RxJava)和`Kotlin`的优点,以及一些 React 中的规则,使得构建新页面变得更加简单,更加流畅.它是由常见的开发模式以及 React 中的优点开发的,是一个\"固定\"([opinionated](https://stackoverflow.com/questions/802050/what-is-opinionated-software))但灵活的框架.它也是线程安全的，几乎所有东西都不在主线程运行，这使得滚动和动画感觉流畅.\n\n到目前为止,它已经应用到了大量的页面中,并且几乎完全不需要处理生命周期.我们目前正在一些 Android 产品上进行试验,并且如果一切顺利的话会将他开源.下面是创建一个发出网络请求的功能页面所需的全部代码:\n\n```Kotlin\ndata class SimpleDemoState(val listing: Async\u003cListing\u003e = Uninitialized)\n\nclass SimpleDemoViewModel(override val initialState: SimpleDemoState) : MvRxViewModel\u003cSimpleDemoState\u003e() {\n    init {\n        fetchListing()\n    }\n\n    private fun fetchListing() {\n        // This automatically fires off a request and maps its response to Async\u003cListing\u003e\n        // which is a sealed class and can be: Unitialized, Loading, Success, and Fail.\n        // No need for separate success and failure handlers!\n        // This request is also lifecycle-aware. It will survive configuration changes and\n        // will never be delivered after onStop.\n        ListingRequest.forListingId(12345L).execute { copy(listing = it) }\n    }\n}\n\nclass SimpleDemoFragment : MvRxFragment() {\n    // This will automatically subscribe to the ViewModel state and rebuild the epoxy models\n    // any time anything changes. Similar to how React's render method runs for every change of\n    // props or state.\n    private val viewModel by fragmentViewModel(SimpleDemoViewModel::class)\n\n    override fun EpoxyController.buildModels() {\n        val (state) = withState(viewModel)\n        if (state.listing is Loading) {\n            loader()\n            return\n        }\n        // These Epoxy models are not the views themself so calling buildModels is cheap. RecyclerView\n        // diffing will be automaticaly done and only the models that changed will re-render.\n        documentMarquee {\n            title(state.listing().name)\n        }\n        // Put the rest of your Epoxy models here...\n    }\n\n    override fun EpoxyController.buildFooter() = fixedActionFooter {\n        val (state) = withState(viewModel)\n        buttonLoading(state is Loading)\n        buttonText(state.listing().price)\n        buttonOnClickListener { _ -\u003e }\n    }\n}\n```\n\nMvRx 具有简单的构造,用于处理 Fragment 参数,跨进程重启时`savedInstanceState`的持久化,TTI 追踪以及一些其他的功能.\n\n我们也正在开发一个相似的 iOS 框架,该框架目前正处于早期测试阶段.\n\n尽管我们已经对目前所取得的进展十分满意了,还是希望很快可以听到更多相关的消息.\n\n### 迭代速度\n\n当从 React Native 切换回原生时,迭代速度是显而易见的问题.测试改动的时间从原本只需要 1~2 秒,变成可能需要等待将近 15 分钟是不可接受的.幸运的是,我们能够从一些方面缓解这一现象.\n\n我们在 Android 和 iOS 上构建的基础设施能够根据功能模块编译启动器和部分 app.\n\n在 Android 端使用了[gradle 产品风格](https://developer.android.com/studio/build/build-variants#product-flavors), 我们的 gradle 模块如下图所示:\n\n![](/static/gradle%20modules.png)\n\n新的间接层使得工程师可以 app 的切片上进行开发.再配合[Intellij module unloadinig](https://blog.jetbrains.com/idea/2017/06/intellij-idea-2017-2-eap-introduces-unloaded-modules/),可以在 Macbook Pro 上动态提高构建和 IDE 的性能.\n\n我们已经构建了用于创建新的测试 flavor 的脚本,并且在短短几个越能,我们已经完成了超过 20 个.使用这些新风格可以使开发构建提速 2.5 倍,并且超过 5 分钟的比例下降了 15 倍.\n\n作为参考,这是用于动态生成具有根依赖性模块产品风格的[gradle 代码块](https://gist.github.com/gpeal/d68e4fc1357ef9d126f25afd9ab4eee2).\n\n相似地,iOS 上的模块如下图所示:\n\n![](/static/iOS%20modules.png)\n\n同样系统的构建速度会提升 3-8 倍.\n\n## 结论\n\n很高兴能够成为一家不怕尝试新技术但又努力保持高质量,高速度和开发体验的公司.最后,React Native 是发布功能,为我们提供了新的移动开发思路的重要工具.如果这听起来像是您想参与的旅程，[请告诉我们](https://www.airbnb.com/careers/departments/engineering)！\n\n_这是 Airbnb 关于 React Native 经验分享和移动端未来计划系列文章的第五篇._\n\n[第一篇: React Native at Airbnb](./react-native-at-airbnb-1)\n\n[第二篇: The Technology](./react-native-at-airbnb-2)\n\n[第三篇: Building a Cross-Platform Mobile Team](./react-native-at-airbnb-3)\n\n[第四篇: Making a Decision on React Native](./react-native-at-airbnb-4)\n\n[第五篇: What's Next for Mobile](./react-native-at-airbnb-5)\n\n- 原文地址：https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab\n- 译文出自：TWNTF\n- 译者：Yingjian Li\n"}},"page":"/post","pathname":"/post","query":{"key":"react-native-at-airbnb-5"},"buildId":"wWB~SiLn_g9IuIhvDzML9","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/post" src="/_next/static/wWB~SiLn_g9IuIhvDzML9/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wWB~SiLn_g9IuIhvDzML9/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/_next/static/wWB~SiLn_g9IuIhvDzML9/pages/_error.js"></script><script src="/_next/static/runtime/webpack-7d4c186a3aecb0bb5bf3.js" async=""></script><script src="/_next/static/chunks/commons.588b470a21a58a43c7dc.js" async=""></script><script src="/_next/static/runtime/main-3f3666d0dcad119f41d5.js" async=""></script></body></html>