<!DOCTYPE html><html style="height:100%" class="jsx-3241352696"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">Next-blog</title><link rel="preload" href="/next-blog/_next/static/uGIiZVgp7uqY2aQyh8G2c/pages/post.js" as="script"/><link rel="preload" href="/next-blog/_next/static/uGIiZVgp7uqY2aQyh8G2c/pages/_app.js" as="script"/><link rel="preload" href="/next-blog/_next/static/uGIiZVgp7uqY2aQyh8G2c/pages/_error.js" as="script"/><link rel="preload" href="/next-blog/_next/static/runtime/webpack-bb13cbd5f4cb95c0e1ff.js" as="script"/><link rel="preload" href="/next-blog/_next/static/chunks/commons.fe4372ab19016575274d.js" as="script"/><link rel="preload" href="/next-blog/_next/static/runtime/main-8c21d63e457d27dcf8e4.js" as="script"/><style id="__jsx-3241352696">div#__next{height:100%;}</style><style id="__jsx-821146791">a.jsx-821146791{margin-right:30px;font-size:20px;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;color:rgba(0,0,0,0.7);}</style><style id="__jsx-1769670723">header.jsx-1769670723{box-shadow:0 0 1px rgba(0,0,0,0.2);-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;}
.header-container.jsx-1769670723{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:0 auto;padding-top:20px;max-width:1000px;padding-bottom:20px;}
div.slogan.jsx-1769670723{display:inline-block;font-weight:bold;font-size:24px;font-family:"Oswald",sans-serif;}
a.jsx-1769670723{-webkit-text-decoration:none;text-decoration:none;cursor:pointer;color:rgba(0,0,0,0.7);}</style><style id="__jsx-3564541774">img{max-width:900px;}
blockquote{padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;margin-left:0;margin-bottom:16px;margin-top:0;}
p,li{word-wrap:break-word;font-size:18px;line-height:1.58;-webkit-letter-spacing:-0.003em;-moz-letter-spacing:-0.003em;-ms-letter-spacing:-0.003em;letter-spacing:-0.003em;}
p>code{padding:0.2em 0.4em;margin:0;font-size:85%;border-radius:3px;font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo, Courier,monospace;}
pre{margin-top:0;margin-bottom:0;}
pre>code{font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo, Courier,monospace;line-height:1.45;}</style><style id="__jsx-1732950521">.footer-container.jsx-1732950521{height:40px;margin-top:40px;background-color:black;}
.footer-content.jsx-1732950521{color:white;max-width:1000px;font-family:"Oswald",sans-serif;margin:10px auto;line-height:1.5;}
a.jsx-1732950521{margin-left:5px;color:white;}</style><style id="__jsx-2994019239">.jsx-2994019239{font-family:"Open Sans","Roboto","Microsoft YaHei","微软雅黑",STXihei, "华文细黑",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:auto;}
.content-container.jsx-2994019239{margin-top:50;-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}
.content.jsx-2994019239{margin:0 auto;max-width:1000px;height:100%;min-height:650px;}</style><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans:300,400,500" class="jsx-3241352696"/><link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet" class="jsx-3241352696"/><link href="/static/dracula.css" rel="stylesheet" class="jsx-3241352696"/><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" class="jsx-3241352696"></script><script class="jsx-3241352696">hljs.initHighlightingOnLoad();</script></head><body style="height:100%;margin:0" class="jsx-3241352696"><div id="__next"><div class="jsx-2994019239"><header class="jsx-1769670723"><div class="jsx-1769670723 header-container"><div class="jsx-1769670723 slogan"><a class="jsx-1769670723" href="/next-blog/">Star Boy</a></div><div class="jsx-821146791"><a class="jsx-821146791" href="/next-blog/">Home</a><a class="jsx-821146791" href="/next-blog/about/">About</a></div></div></header><div class="jsx-2994019239 content-container"><div class="jsx-2994019239 content"><div class="jsx-3564541774"><h1>对比 Redux 和 Context API</h1>
<p><img src="/static/context-vs-redux@2x.png" alt=""></p>
<p>React 在 16.3 版本中添加了一个新的 Context API， 「新」的意思是指之前的 Context API 是一个隐藏的功能。 由于在官方文档中并不鼓励使用 Context API， 大多数人都避免使用它，甚至都不知道它的存在。</p>
<p>而现在 Context API 变成了 React 中的一等公民， 并且开放给了所有人(来自官方推广)。</p>
<p>React 16.3 一发布， 网上的很多文章就因新 Context API 的出现，宣布「Redux 已死」。 然而如果你问过 Redux，我相信它会回答你:「那些言论都是<a href="https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/">夸大其词</a>」。</p>
<p>本文将会介绍新 Context API 是如何工作的， 它与 Redux 的相似之处， 什么时候应该选用 Context，以及为什么 Context 并不能完全取代 Redux。</p>
<p>如果你只想大致了解 Context， 可以直接<a href="#how-to-use-context-api">查看</a>。</p>
<h2>一个简单的 React 例子</h2>
<p>现在，假设你已经清楚 React 的基础概念(props &amp; state)， 如果你还不清楚， 这里有一个免费的五天课程可以帮助你<a href="https://daveceddia.com/pure-react-email-course">学习 React</a>。</p>
<p>让我们看一下这个大多数人会选择使用 Redux 的例子.我们首先从简单的纯 React 版本开始，再看一下如何使用 Redux，最后是 Context。</p>
<p><img src="/static/example.png" alt=""></p>
<p>这个 app 在两处地方显示用户的信息:一个是在导航栏的右上角，一个是在主要内容左侧的侧栏。</p>
<p>(你也许注意到了， 这看起来很像 Twitter。这并非偶然！ 磨炼 React 技术最好的方法就是<a href="https://daveceddia.com/learn-react-with-copywork/">模仿</a>)。</p>
<p>组件结构如下图:</p>
<p><img src="/static/component-structure.png" alt=""></p>
<p>如果只使用 React(普通的 props)， 需要把用户信息存在组件树中足够高的位置， 以便于把 props 向下传递到需要的组件中。在这种情况下，用户信息只能存储在<code>App</code>中。</p>
<p>然后，为了将 props 传递到需要的组件中，App 需要把 props 先传递到 Nav 和 Body 中。 然后需要再依次向下传递，到 UserAvatar(万岁!)和 Sidebar 中。最后， SideBar 必须再向下传递到 UserStats 中。</p>
<p>下面让我们看看如何用代码实现(我将所有的内容放到了一个文件中来增加易读性，但在真实情况下可能需要按照<a href="https://daveceddia.com/react-project-structure/">某种标准结构</a>将它拆成多个独立的文件)。</p>
<pre><code class="language-Javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./styles.css"</span>;

<span class="hljs-keyword">const</span> UserAvatar = <span class="hljs-function">(<span class="hljs-params">{ user， size }</span>) =&gt;</span> (
  &lt;img
    className={`user-avatar ${size || ""}`}
    alt="user avatar"
    src={user.avatar}
  /&gt;
);

const UserStats = ({ user }) =&gt; (
  &lt;div className="user-stats"&gt;
    &lt;div&gt;
      &lt;UserAvatar user={user} /&gt;
      {user.name}
    &lt;/div&gt;
    &lt;div className="stats"&gt;
      &lt;div&gt;{user.followers} Followers&lt;/div&gt;
      &lt;div&gt;Following {user.following}&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

const Nav = ({ user }) =&gt; (
  &lt;div className="nav"&gt;
    &lt;UserAvatar user={user} size="small" /&gt;
  &lt;/div&gt;
);

const Content = () =&gt; &lt;div className="content"&gt;main content here&lt;/div&gt;;

const Sidebar = ({ user }) =&gt; (
  &lt;div className="sidebar"&gt;
    &lt;UserStats user={user} /&gt;
  &lt;/div&gt;
);

const Body = ({ user }) =&gt; (
  &lt;div className="body"&gt;
    &lt;Sidebar user={user} /&gt;
    &lt;Content user={user} /&gt;
  &lt;/div&gt;
);

class App extends React.Component {
  state = {
    user: {
      avatar:
        "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b"，
      name: "Dave"，
      followers: 1234，
      following: 123
    }
  };

  render() {
    const { user } = this.state;

    return (
      &lt;div className="app"&gt;
        &lt;Nav user={user} /&gt;
        &lt;Body user={user} /&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(&lt;App /&gt;， document.querySelector("#root"));
</code></pre>
<p><a href="https://codesandbox.io/s/q8yqx48074">CodeSandbox 上的示例。</a></p>
<p>在上面的代码中， <code>App</code><a href="https://daveceddia.com/where-initialize-state-react/">初始化</a>了包含 user 对象的 state， 在实际情况下，你可能需要<a href="https://daveceddia.com/ajax-requests-in-react/">从服务端获取数据</a>， 并将其保存在 state 中，用于渲染。</p>
<p>从 prop drilling 的角度来看，上面代码的问题并不严重。而且我们也绝对不会反对使用 prop drilling，它完全合理并且是 React 工作的核心方式。但是在写代码时层次过深会有一点厌烦，尤其当你需要传递多个 props 时。</p>
<p>Prop drilling 还有一个缺点就是:它使原本无关的组件之间产生了耦合。在上面的例子中，即使<code>Nav</code>并不需要<code>user</code>属性，但还是需要接收 user 属性，并且还要传递给<code>UserAvatar</code>。</p>
<p>紧耦合的组件(将 props 转发给子组件的组件)很难重用，因为在使用这类组件时，你需要在它们的父组件中准备好这些属性。</p>
<p>那么我们如何改进呢?</p>
<h2>在使用 Redux 或 Context API 之前</h2>
<p>如果你可以<strong>合并</strong>你的 app 结构，并且利用<code>childern</code>属性，无需借助 prop drilling， Context 或 Redux，也可以使你的代码会变得简洁。</p>
<p>对于像<code>Nav</code>，<code>Sidebar</code>和<code>Body</code>一样，需要成为占位符的组件来说，chilren 属性是一个很好的解决方案。众所周知，你可以使用<strong>任何</strong>属性传递 JSX 组件，并非一定要使用 children。因此如果你需要多个入口来注入组件，请牢记这一点。</p>
<p>这个版本的 React 示例中， <code>Nav</code>，<code>Body</code>和<code>Sidebar</code>接收 chilren 属性，并且按照他们原有的方式进行渲染。这样就不再需要担心如何传递特定的属性，只需要合理地使用组件自身的属性进行渲染即可。这个例子还展示了如何使用<strong>任意</strong>属性来传递 children。</p>
<p>(感谢 Dan Abramov 提出的<a href="https://twitter.com/dan_abramov/status/1021850499618955272">建议</a>!)</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./styles.css"</span>;

<span class="hljs-keyword">const</span> UserAvatar = <span class="hljs-function">(<span class="hljs-params">{ user， size }</span>) =&gt;</span> (
  &lt;img
    className={`user-avatar ${size || ""}`}
    alt="user avatar"
    src={user.avatar}
  /&gt;
);

const UserStats = ({ user }) =&gt; (
  &lt;div className="user-stats"&gt;
    &lt;div&gt;
      &lt;UserAvatar user={user} /&gt;
      {user.name}
    &lt;/div&gt;
    &lt;div className="stats"&gt;
      &lt;div&gt;{user.followers} Followers&lt;/div&gt;
      &lt;div&gt;Following {user.following}&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

// 接收 children 并且渲染
const Nav = ({ children }) =&gt; (
  &lt;div className="nav"&gt;
    {children}
  &lt;/div&gt;
);

const Content = () =&gt; (
  &lt;div className="content"&gt;main content here&lt;/div&gt;
);

const Sidebar = ({ children }) =&gt; (
  &lt;div className="sidebar"&gt;
    {children}
  &lt;/div&gt;
);

// Body 需要一个 sidebar 和 content， 但用这种形式写，
// 他们可以是任何属性
const Body = ({ sidebar， content }) =&gt; (
  &lt;div className="body"&gt;
    &lt;Sidebar&gt;{sidebar}&lt;/Sidebar&gt;
    {content}
  &lt;/div&gt;
);

class App extends React.Component {
  state = {
    user: {
      avatar:
        "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b"，
      name: "Dave"，
      followers: 1234，
      following: 123
    }
  };

  render() {
    const { user } = this.state;

    return (
      &lt;div className="app"&gt;
        &lt;Nav&gt;
          &lt;UserAvatar user={user} size="small" /&gt;
        &lt;/Nav&gt;
        &lt;Body
          sidebar={&lt;UserStats user={user} /&gt;}
          content={&lt;Content /&gt;}
        /&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(&lt;App /&gt;， document.querySelector("#root"));
</code></pre>
<p><a href="https://codesandbox.io/s/mj19ywz0oy">CodeSandbox 上的示例。</a></p>
<p>如果你的 app 十分复杂(比这个例子复杂的多!)，可能很难使用<code>children</code>的模式。下面让我们将介绍如何使用 Redux 来避免 prop drilling。</p>
<h2>Redux 示例</h2>
<p>我们先来看一下 Redux 的示例，再仔细观察 Context 是如何工作的。如果你对 Redux 并不熟悉，可以先阅读我写的<a href="https://daveceddia.com/how-does-redux-work/">Redux 简介</a>(或者<a href="https://youtu.be/sX3KeP7v7Kg">观看视频</a>)。</p>
<p>将上面的 app 用 Redux 重构后，<code>user</code>信息存储在 Redux store 中。这意味着我们可以使用 react-redux 的<code>connect</code>方法直接向组件中注入<code>user</code>属性。</p>
<p>这样就实现了组件间的解耦。 <code>Nav</code>， <code>Body</code>和<code>Siderbar</code>不再接收和传递<code>user</code>属性。再也不需要接收无用的属性，再也不存在无用的耦合。</p>
<p>其中的 reducer 也都十分简单。我在<a href="https://daveceddia.com/what-is-a-reducer/">Redux 中的 reducers 是如何工作的</a>和<a href="https://daveceddia.com/immutable-updates-react-redux/">如何写出 immutable 代码</a>中对这方面知识进行了更详细的介绍。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

<span class="hljs-comment">// 我们需要 createStore, connect 和 Provider:</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">"redux"</span>;
<span class="hljs-keyword">import</span> { connect, Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-redux"</span>;

<span class="hljs-comment">// 创建一个带有初始空 state 的 reducer</span>
<span class="hljs-keyword">const</span> initialState = {};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-comment">// 响应 the SET_USER 并更新 state</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"SET_USER"</span>:
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">user</span>: action.user
      };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}

<span class="hljs-comment">// 利用 reducer 创建 store</span>
<span class="hljs-keyword">const</span> store = createStore(reducer);

<span class="hljs-comment">// 派发一个 action 来设置 user 的值</span>
<span class="hljs-comment">// 因为初始化的 state 是空的</span>
store.dispatch({
  <span class="hljs-attr">type</span>: <span class="hljs-string">"SET_USER"</span>,
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">avatar</span>: <span class="hljs-string">"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Dave"</span>,
    <span class="hljs-attr">followers</span>: <span class="hljs-number">1234</span>,
    <span class="hljs-attr">following</span>: <span class="hljs-number">123</span>
  }
});

<span class="hljs-comment">// mapStateToProps 方法从 state 中抽取了一个 key（user）</span>
<span class="hljs-comment">// 并用`user`属性进行传递</span>
<span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({
  <span class="hljs-attr">user</span>: state.user
});

<span class="hljs-comment">// connect() 使 UserAvatar 可以直接接收 `user`</span>
<span class="hljs-comment">// 而无需从父组件中接收</span>

<span class="hljs-comment">// 还可以分割成两个变量：</span>
<span class="hljs-comment">//   const UserAvatarAtom = ({ user, size }) =&gt; ( ... )</span>
<span class="hljs-comment">//   const UserAvatar = connect(mapStateToProps)(UserAvatarAtom);</span>
<span class="hljs-keyword">const</span> UserAvatar = connect(mapStateToProps)(<span class="hljs-function">(<span class="hljs-params">{ user, size }</span>) =&gt;</span> (
  &lt;img
    className={`user-avatar ${size || ""}`}
    alt="user avatar"
    src={user.avatar}
  /&gt;
));

// connect() 使 UserStats 可以直接接收`user`
// 而无需从父组件中接收
// 两个组件可以使用同一个 mapStateToProps 方法
const UserStats = connect(mapStateToProps)(({ user }) =&gt; (
  &lt;div className="user-stats"&gt;
    &lt;div&gt;
      &lt;UserAvatar /&gt;
      {user.name}
    &lt;/div&gt;
    &lt;div className="stats"&gt;
      &lt;div&gt;{user.followers} Followers&lt;/div&gt;
      &lt;div&gt;Following {user.following}&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
));

// Nav 不再需要知道 `user`
const Nav = () =&gt; (
  &lt;div className="nav"&gt;
    &lt;UserAvatar size="small" /&gt;
  &lt;/div&gt;
);

const Content = () =&gt; &lt;div className="content"&gt;main content here&lt;/div&gt;;

// Sidebar 不再需要知道 `user`
const Sidebar = () =&gt; (
  &lt;div className="sidebar"&gt;
    &lt;UserStats /&gt;
  &lt;/div&gt;
);

// Body 不再需要知道 `user`
const Body = () =&gt; (
  &lt;div className="body"&gt;
    &lt;Sidebar /&gt;
    &lt;Content /&gt;
  &lt;/div&gt;
);

// App 不再维护 state， 可以简化成一个无状态的函数
const App = () =&gt; (
  &lt;div className="app"&gt;
    &lt;Nav /&gt;
    &lt;Body /&gt;
  &lt;/div&gt;
);

// 将整个 app 用 Provider 包起来，使 connect()
// 能够连接到 store
ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.querySelector("#root")
);
</code></pre>
<p><a href="https://codesandbox.io/s/943yr0qp3o">CodeSandbox 上的示例。</a></p>
<p>现在你也许想知道 Redux 是如何实现这种魔法的。这是个好问题，为什么 React 中不支持多层传递属性，而 Redux 就可以呢？</p>
<p>答案是 Redux 使用了 React 中的 Context 功能。不过不是新的 Context API，而是老版本 Context。 React 文档中明确说明，除非是用于第三方库或明确知道自己在做什么，否则不推荐使用 Context。</p>
<p>Context 就像是一个运行在组件身后的总线：如果你想从中接收电力（数据），只需要插上电源就可以了（React-Redux 的 <code>connect()</code>方法）。</p>
<p>这部分功能只是 Redux 的冰山一角。自由传递属性只是 Redux 最<strong>表面</strong>的功能。除此之外，Redux 还有一些其他的优点：</p>
<h3>「纯」的<code>connect</code></h3>
<p><code>connect</code> 会自动使连接的组件变成「纯组件」，这也就意味着它们只有在 props 发生变化，也就是 Redux store 中对应的值发生变化时才会重新渲染。这防止了不必要的重新渲染，保证 app 可以快速运行。DIY 方法：创建一个继承 <code>PureComponent</code> 的类，或自己实现<code>shouldComponentUpdate</code>。</p>
<h3>Redux 可以简化调试</h3>
<p>actions 和 reducers 的样板代码带来的一个好处就是强大的调试功能。</p>
<p>使用 <a href="https://github.com/zalmoxisus/redux-devtools-extension">Redux DevTools Extension</a> 可以帮助你自动记录 app 中的每一个 action。你可以在任何时候打开它，查看触发了哪些 actions，他们的 payload 是什么，以及 action 发生前后的 state 变化。</p>
<p><img src="/static/redux-devtools.gif" alt=""></p>
<p>Redux DevTools 的另一个重要功能是时间旅行调试，也就是说你可以通过点击已发生的 action 跳转到该时间点，也就是重播在那之前的所有 actions（包含该 action 本身）。这是由于每个 action 都是 <strong>immutably</strong> 更新 state，因此你可以获取到 state 更新列表，并且无副作用的随意重播。</p>
<p>还有像 <a href="https://logrocket.com/">LogRocket</a> 这种的工具，可以在每一个用户的<strong>产品环境</strong>上提供始终开启的 Redux DevTools。收到了 bug 报告？没问题，在 LogRocket 中查找用户的会话，你就可以看到他们的操作记录和触发的 actions。这一切都是通过挖掘 Redux 的 action 流完成的。</p>
<h3>自定义 Redux 中间件</h3>
<p>Redux 支持<strong>中间件</strong>。中间件的意思是「每次派发 action 时都会执行的方法」。实现你自己的中间件并没有看起来那么难，而且能够完成许多强大的功能。</p>
<p>例如：</p>
<ul>
<li>想要在 action name 是以 <code>FETCH_</code> 为前缀时，开始 API 请求？ 你可以用中间件来实现。</li>
<li>想要在集中地将日志发送给分析软件？中间件是个不错的解决方案。</li>
<li>想要在特定时间内阻止某些特定 actions 触发？你可以使用中间件来实现，不会对 app 的其余部分产生影响。</li>
<li>想要自动地拦截带有 JWT token 的 action，并把他们存到 localStorage 中？没错，中间件。</li>
</ul>
<p>这里有一篇关于<a href="https://medium.com/@jacobp100/you-arent-using-redux-middleware-enough-94ffe991e6">如何写 Redux 中间件</a>的文章。</p>
<h2><a name="how-to-use-context-api"></a>如何使用 Context API</h2>
<p>但是也许你不需要 Redux 中那些花哨的功能。也许你不需要简单的调试，定制化，或性能提升，你只是希望数据的传递能变得简单些。也许你的 app 很小，或者需要先让某些功能正常工作后，再考虑引入一些其他的库。</p>
<p>React 的新 Context API 也许很适合你。让我们看看它是如何工作的。</p>
<p>我在 Egghead 上发布了一个简短的 Context API 课程， 如果你们更喜欢看视频，可以参考<a href="https://egghead.io/lessons/react-pass-props-through-multiple-levels-with-react-s-context-api">这里</a>。</p>
<p>Context API 中有三个重要的部分：</p>
<ul>
<li><code>React.createContext</code> 生成 Context。</li>
<li><code>Provider</code>（由<code>createContext</code>返回）创建贯穿整个组件树的「总线」。</li>
<li><code>Consumer</code>（也是由<code>createContext</code>生成，接通「总线」以获取数据。</li>
</ul>
<p>这里的<code>Provider</code>和 React-Redux 里的<code>Provider</code>很像。接收任何形式的<code>value</code>属性（也可以是 Redux store，但是这样做很蠢）。大多数情况下都是包含一些数据和操作这些数据的方法的对象。</p>
<p>而<code>Consumer</code>和 React-Redux 的<code>connect</code>方法有点像，接通数据并提供给组件。</p>
<p>接下来是重点：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 首先，我们生成一个新的 Context</span>
<span class="hljs-comment">// 这是一个包含了两个属性的对象: { Provider, Consumer }</span>
<span class="hljs-comment">// 切记命名方式是帕斯卡式而不是驼峰式</span>
<span class="hljs-comment">// 这十分重要，因为我们一会要把它用作一个组件</span>
<span class="hljs-comment">// 组件名必须要以大写字母开始</span>
<span class="hljs-keyword">const</span> UserContext = React.createContext();

<span class="hljs-comment">// 需要数据的组件使用 Consumer 属性接通 context</span>
<span class="hljs-comment">// Consumer 使用「render props」模式。</span>
<span class="hljs-keyword">const</span> UserAvatar = <span class="hljs-function">(<span class="hljs-params">{ size }</span>) =&gt;</span> (
  &lt;UserContext.Consumer&gt;
    {user =&gt; (
      &lt;img
        className={`user-avatar ${size || ""}`}
        alt="user avatar"
        src={user.avatar}
      /&gt;
    )}
  &lt;/UserContext.Consumer&gt;
);

// 注意，我们不再是需要 user 属性
// 因为 Consumer 可以从 context 中直接获取
const UserStats = () =&gt; (
  &lt;UserContext.Consumer&gt;
    {user =&gt; (
      &lt;div className="user-stats"&gt;
        &lt;div&gt;
          &lt;UserAvatar user={user} /&gt;
          {user.name}
        &lt;/div&gt;
        &lt;div className="stats"&gt;
          &lt;div&gt;{user.followers} Followers&lt;/div&gt;
          &lt;div&gt;Following {user.following}&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )}
  &lt;/UserContext.Consumer&gt;
);

// ... 其他组件 ...
// ... 不在需要关注 `user` 属性

// 最后，在 App 中，我们利用 Provider
// 向下传递 context
class App extends React.Component
  state = {
    user: {
      avatar:
        "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b",
      name: "Dave",
      followers: 1234,
      following: 123
    }
  };

  render() {
    return (
      &lt;div className="app"&gt;
        &lt;UserContext.Provider value={this.state.user}&gt;
          &lt;Nav /&gt;
          &lt;Body /&gt;
        &lt;/UserContext.Provider&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p><a href="https://codesandbox.io/s/q9w2qrw6q4">CodeSandbox 上的示例。</a></p>
<p>让我们回顾一下它是如何工作的。</p>
<p>记住一共三个部分： context 自身（由 <code>React.createContext</code> 创建），还有两个组件（<code>Provider</code> 和 <code>Consumer</code>）。</p>
<h3>Provider 和 Consumer 是对应的</h3>
<p>Provider 和 Consumer 是绑定在一起的，不可分割。而且它们只知道如何与<strong>对方</strong>通信。如果你创建了两个不同的 contexts， 「Context1」和「Context2」，则 Context1 的 Provider 和 Consumer 无法与 Context2 的 Provider 和 Consumer 通信。</p>
<h3>Context 不存储状态</h3>
<p>注意，context 自身<strong>并没有自身的 state</strong>。 它仅仅是数据的管道，向<code>Provider</code>中传入数据，传递到对应的<code>Consumer</code>中。</p>
<p>当你在创建 context 时，可以像这样的传人「默认值」：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> Ctx = React.createContext(yourDefaultValue);
</code></pre>
<p>当 <code>Consumer</code> 上方没有 <code>Provider</code> 时，会使用默认值。如果不传的话， 默认值就是 <code>undefined</code>。 切记，这是<strong>默认值</strong>， 不是<strong>初始</strong>值。context 不保留任何值，只是传递你输入的数据。</p>
<h3>Consumer 使用 Render Props 模式</h3>
<p>Redux 的 <code>connect</code> 是一个高阶组件（HoC），<strong>封装</strong>另一个组件，并且将值传递给它。</p>
<p>相反的是，context 中的 <code>Consumer</code> 期望它的子组件是一个函数。 它在渲染时调用该函数，将从上层 <code>Provider</code> 中获取的值（或者是 context 的默认值，或者是 <code>undefined</code>）传进去。</p>
<h3>Provider 只接收一个值</h3>
<p>Provider 只接收 <code>value</code> 属性。但传入的值可以是任何类型的。 如果你想传递多个值，你可以创建一个包含多个值的对象，并把该<strong>对象</strong>传递下去。</p>
<p>以上就是 Context API 的大致内容了。</p>
<h2>Context API 十分灵活</h2>
<p>因为创建 Context 会为我们提供两个可供自由使用的组件（Provier 和 Consumer）。下面是一些想法：</p>
<h3>将 Consumer 转化成高阶组件</h3>
<p>不想在每次使用时都添加 <code>UserContext.Consumer</code>？当然可以，这是你自己的代码！你已经成年了。</p>
<p>如果你更喜欢通过属性的方式接收数据，可以对 <code>Consumer</code> 进行简单的封装，像这样：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withUser</span>(<span class="hljs-params">Component</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ConnectedComponent</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">return</span> (
      &lt;UserContext.Consumer&gt;
        {user =&gt; &lt;Component {...props} user={user} /&gt;}
      &lt;/UserContext.Consumer&gt;
    );
  };
}
</code></pre>
<p>还可以用 <code>withUser</code> 重写 <code>UserAvatar</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> UserAvatar = withUser(<span class="hljs-function">(<span class="hljs-params">{ size, user }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>
    <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">user-avatar</span> ${<span class="hljs-attr">size</span> || ""}`}
    <span class="hljs-attr">alt</span>=<span class="hljs-string">"user avatar"</span>
    <span class="hljs-attr">src</span>=<span class="hljs-string">{user.avatar}</span>
  /&gt;</span>
));
</span></code></pre>
<p>BOOM! 你可以像使用 Redux 的 <code>connect</code> 一样使用 context, 但是无法将组件自动变成「纯组件」。</p>
<h3>在 Provider 中维护 state</h3>
<p>还记得么， context 中的 Provider 只是一个传递数据的管道，无法维护任何数据。但你可以自己封装 Provider，来维护数据。</p>
<p>在上面的例子中，我将数据都存储在 <code>App</code> 中，是为了帮助你更好地理解 Provider 和 Consumer。但是也许你想用生成一个自己的「store」。你可以自己创建一个维护和传递数据的组件：</p>
<pre><code class="language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">user</span>: {
      <span class="hljs-attr">avatar</span>:
        <span class="hljs-string">"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b"</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">"Dave"</span>,
      <span class="hljs-attr">followers</span>: <span class="hljs-number">1234</span>,
      <span class="hljs-attr">following</span>: <span class="hljs-number">123</span>
    }
  };

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.user}</span>&gt;</span>
        {this.props.children}
      <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span>
    );
  }
}

// ... 跳过中间部分 ...

const App = () =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Nav</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Body</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);

ReactDOM.render(
  <span class="hljs-tag">&lt;<span class="hljs-name">UserStore</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">UserStore</span>&gt;</span>,
  document.querySelector("#root")
);
</span></code></pre>
<p>现在 <code>UserStore</code> 唯一的职责就是维护 user 数据。太棒了， <code>App</code> 现在又是无状态组件，而且看起来更整洁了。</p>
<p><a href="https://codesandbox.io/s/jpy76nm1v">CodeSandbox 上的示例。</a></p>
<h3>使用 Context 传递 Actions</h3>
<p>通过 <code>Provider</code> 向下传递的对象中可以包含任何类型的数据，当然也就包括函数。你也可以叫「actions」。</p>
<p>下面是一个简单的例子：一个简单的房间，还有一个开关来切换背景颜色-对不起，我是指灯光。</p>
<p><img src="/static/lightswitch-app.gif" alt=""></p>
<p>store 中不但包含灯光状态，还包含了切换灯光状态的函数，并且都将使用 context 向下传递。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./styles.css"</span>;

<span class="hljs-comment">// 空的 context</span>
<span class="hljs-keyword">const</span> RoomContext = React.createContext();

<span class="hljs-comment">// 本组件的唯一的职责：管理 Room 状态的组件</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoomStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">isLit</span>: <span class="hljs-literal">false</span>
  };

  toggleLight = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({ <span class="hljs-attr">isLit</span>: !state.isLit }));
  };

  render() {
    <span class="hljs-comment">// 向下传递 state 和 onToggleLight</span>
    <span class="hljs-keyword">return</span> (
      &lt;RoomContext.Provider
        value={{
          isLit: this.state.isLit,
          onToggleLight: this.toggleLight
        }}
      &gt;
        {this.props.children}
      &lt;/RoomContext.Provider&gt;
    );
  }
}

// 从 RoomContext 接收 state 和控制函数
const Room = () =&gt; (
  &lt;RoomContext.Consumer&gt;
    {({ isLit, onToggleLight }) =&gt; (
      &lt;div className={`room ${isLit ? "lit" : "dark"}`}&gt;
        The room is {isLit ? "lit" : "dark"}.&lt;br /&gt;
        &lt;button onClick={onToggleLight}&gt;Flip&lt;/button&gt;
      &lt;/div&gt;
    )}
  &lt;/RoomContext.Consumer&gt;
);

const App = () =&gt; (
  &lt;div className="app"&gt;
    &lt;Room /&gt;
  &lt;/div&gt;
);

// 将整个 App 包装在 RoomStore 中
// 在 `App` 中包装也可以
ReactDOM.render(
  &lt;RoomStore&gt;
    &lt;App /&gt;
  &lt;/RoomStore&gt;,
  document.querySelector("#root")
);
</code></pre>
<p><a href="https://codesandbox.io/s/jvky9o0nvw">CodeSandbox 上的示例。</a></p>
<h2>应该选择 Context 还是 Redux 呢</h2>
<p>现在你已经了解了它们的工作方式，你应该选择哪一个？<strong>想清楚后再做决定</strong>可以使你的 app 变得更好，写起来更有趣。我知道你也许只想要一个确定的「答案」，但我很遗憾的告诉你，「要视情况而定」。</p>
<p>这依赖于 app 的大小，或将来的大小。将会有多少人进行开发 - 只有你，还是一个更大的团队？你或你的团队对于函数式的概念（Redux 依赖于此，像 immutability 和纯函数等）掌握如何？</p>
<p>现在 JavaScript 生态系统中弥漫着一股竞争的气息，这是十分错误而且有害的。好像每一个选择都是零和博弈：如果你使用了<strong>库 A</strong>，那么你一定不能使用<strong>它的竞争对手库 B</strong>。当一个新的库发布时，一定在某种程度上比现有的库会更好一些，而且会将其取代。感觉所有的事情都是二选一，要么选择最好的，要么和过去的开发者一起退居幕后。</p>
<p>将一系列选择看做工具箱会是一个更好的方案。像是选择用螺丝刀还是冲击起子。对于 80%的工作来说，冲击起子可以更快地固定螺丝。但对于另外的 20%，也许因为空间太小，或物品十分精致等原因，其实螺丝刀是一个更好的选择。当我得到冲击起子时，我不会立即丢弃螺丝刀，还有我的电钻。冲击起子无法<strong>取代</strong>其他的工具，它只是为我提供了另一个选项，另一个解决问题的方式。</p>
<p>Context 完全不会「取代」Redux，就像 React 无法「取代」 Angular 或 jQuery。当我需要很快完成一些事情时，我还是会使用 jQuery。我有时还会使用服务器端渲染的 EJS 模板而不是启动一个完整的 React app。有时你的任务完全不需要 React 或 Redux 来完成。</p>
<p>如今，当 Redux 的功能超过了你所需要的， 你可以选择 Context。</p>
<ul>
<li>原文地址：<a href="https://daveceddia.com/context-api-vs-redux/#how-to-use-the-react-context-api">https://daveceddia.com/context-api-vs-redux/#how-to-use-the-react-context-api</a></li>
<li>译文出自：TWNTF</li>
<li>译者：Yingjian Li</li>
</ul>
</div></div></div><footer style="flex:0 0 auto" class="jsx-1732950521"><div class="jsx-1732950521 footer-container"><div class="jsx-1732950521 footer-content">© 2018 Yingjian Li. Powered by:<a href="https://nextjs.org/" class="jsx-1732950521">Next.js</a>. Inspired by<a href="https://github.com/frostfan/hexo-theme-polarbear" class="jsx-1732950521">Polar Bear</a></div></div></footer></div></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"content":"| date       | tag         |\n| ---------- | ----------- |\n| 2018-07-26 | React,Redux |\n\n---\n\n# 对比 Redux 和 Context API\n\n![](/static/context-vs-redux@2x.png)\n\nReact 在 16.3 版本中添加了一个新的 Context API， 「新」的意思是指之前的 Context API 是一个隐藏的功能。 由于在官方文档中并不鼓励使用 Context API， 大多数人都避免使用它，甚至都不知道它的存在。\n\n而现在 Context API 变成了 React 中的一等公民， 并且开放给了所有人(来自官方推广)。\n\nReact 16.3 一发布， 网上的很多文章就因新 Context API 的出现，宣布「Redux 已死」。 然而如果你问过 Redux，我相信它会回答你:「那些言论都是[夸大其词](https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/)」。\n\n本文将会介绍新 Context API 是如何工作的， 它与 Redux 的相似之处， 什么时候应该选用 Context，以及为什么 Context 并不能完全取代 Redux。\n\n如果你只想大致了解 Context， 可以直接[查看](#how-to-use-context-api)。\n\n## 一个简单的 React 例子\n\n现在，假设你已经清楚 React 的基础概念(props \u0026 state)， 如果你还不清楚， 这里有一个免费的五天课程可以帮助你[学习 React](https://daveceddia.com/pure-react-email-course)。\n\n让我们看一下这个大多数人会选择使用 Redux 的例子.我们首先从简单的纯 React 版本开始，再看一下如何使用 Redux，最后是 Context。\n\n![](/static/example.png)\n\n这个 app 在两处地方显示用户的信息:一个是在导航栏的右上角，一个是在主要内容左侧的侧栏。\n\n(你也许注意到了， 这看起来很像 Twitter。这并非偶然！ 磨炼 React 技术最好的方法就是[模仿](https://daveceddia.com/learn-react-with-copywork/))。\n\n组件结构如下图:\n\n![](/static/component-structure.png)\n\n如果只使用 React(普通的 props)， 需要把用户信息存在组件树中足够高的位置， 以便于把 props 向下传递到需要的组件中。在这种情况下，用户信息只能存储在`App`中。\n\n然后，为了将 props 传递到需要的组件中，App 需要把 props 先传递到 Nav 和 Body 中。 然后需要再依次向下传递，到 UserAvatar(万岁!)和 Sidebar 中。最后， SideBar 必须再向下传递到 UserStats 中。\n\n下面让我们看看如何用代码实现(我将所有的内容放到了一个文件中来增加易读性，但在真实情况下可能需要按照[某种标准结构](https://daveceddia.com/react-project-structure/)将它拆成多个独立的文件)。\n\n```Javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles.css\";\n\nconst UserAvatar = ({ user， size }) =\u003e (\n  \u003cimg\n    className={`user-avatar ${size || \"\"}`}\n    alt=\"user avatar\"\n    src={user.avatar}\n  /\u003e\n);\n\nconst UserStats = ({ user }) =\u003e (\n  \u003cdiv className=\"user-stats\"\u003e\n    \u003cdiv\u003e\n      \u003cUserAvatar user={user} /\u003e\n      {user.name}\n    \u003c/div\u003e\n    \u003cdiv className=\"stats\"\u003e\n      \u003cdiv\u003e{user.followers} Followers\u003c/div\u003e\n      \u003cdiv\u003eFollowing {user.following}\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n);\n\nconst Nav = ({ user }) =\u003e (\n  \u003cdiv className=\"nav\"\u003e\n    \u003cUserAvatar user={user} size=\"small\" /\u003e\n  \u003c/div\u003e\n);\n\nconst Content = () =\u003e \u003cdiv className=\"content\"\u003emain content here\u003c/div\u003e;\n\nconst Sidebar = ({ user }) =\u003e (\n  \u003cdiv className=\"sidebar\"\u003e\n    \u003cUserStats user={user} /\u003e\n  \u003c/div\u003e\n);\n\nconst Body = ({ user }) =\u003e (\n  \u003cdiv className=\"body\"\u003e\n    \u003cSidebar user={user} /\u003e\n    \u003cContent user={user} /\u003e\n  \u003c/div\u003e\n);\n\nclass App extends React.Component {\n  state = {\n    user: {\n      avatar:\n        \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\"，\n      name: \"Dave\"，\n      followers: 1234，\n      following: 123\n    }\n  };\n\n  render() {\n    const { user } = this.state;\n\n    return (\n      \u003cdiv className=\"app\"\u003e\n        \u003cNav user={user} /\u003e\n        \u003cBody user={user} /\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\nReactDOM.render(\u003cApp /\u003e， document.querySelector(\"#root\"));\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/q8yqx48074)\n\n在上面的代码中， `App`[初始化](https://daveceddia.com/where-initialize-state-react/)了包含 user 对象的 state， 在实际情况下，你可能需要[从服务端获取数据](https://daveceddia.com/ajax-requests-in-react/)， 并将其保存在 state 中，用于渲染。\n\n从 prop drilling 的角度来看，上面代码的问题并不严重。而且我们也绝对不会反对使用 prop drilling，它完全合理并且是 React 工作的核心方式。但是在写代码时层次过深会有一点厌烦，尤其当你需要传递多个 props 时。\n\nProp drilling 还有一个缺点就是:它使原本无关的组件之间产生了耦合。在上面的例子中，即使`Nav`并不需要`user`属性，但还是需要接收 user 属性，并且还要传递给`UserAvatar`。\n\n紧耦合的组件(将 props 转发给子组件的组件)很难重用，因为在使用这类组件时，你需要在它们的父组件中准备好这些属性。\n\n那么我们如何改进呢?\n\n## 在使用 Redux 或 Context API 之前\n\n如果你可以**合并**你的 app 结构，并且利用`childern`属性，无需借助 prop drilling， Context 或 Redux，也可以使你的代码会变得简洁。\n\n对于像`Nav`，`Sidebar`和`Body`一样，需要成为占位符的组件来说，chilren 属性是一个很好的解决方案。众所周知，你可以使用**任何**属性传递 JSX 组件，并非一定要使用 children。因此如果你需要多个入口来注入组件，请牢记这一点。\n\n这个版本的 React 示例中， `Nav`，`Body`和`Sidebar`接收 chilren 属性，并且按照他们原有的方式进行渲染。这样就不再需要担心如何传递特定的属性，只需要合理地使用组件自身的属性进行渲染即可。这个例子还展示了如何使用**任意**属性来传递 children。\n\n(感谢 Dan Abramov 提出的[建议](https://twitter.com/dan_abramov/status/1021850499618955272)!)\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles.css\";\n\nconst UserAvatar = ({ user， size }) =\u003e (\n  \u003cimg\n    className={`user-avatar ${size || \"\"}`}\n    alt=\"user avatar\"\n    src={user.avatar}\n  /\u003e\n);\n\nconst UserStats = ({ user }) =\u003e (\n  \u003cdiv className=\"user-stats\"\u003e\n    \u003cdiv\u003e\n      \u003cUserAvatar user={user} /\u003e\n      {user.name}\n    \u003c/div\u003e\n    \u003cdiv className=\"stats\"\u003e\n      \u003cdiv\u003e{user.followers} Followers\u003c/div\u003e\n      \u003cdiv\u003eFollowing {user.following}\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n);\n\n// 接收 children 并且渲染\nconst Nav = ({ children }) =\u003e (\n  \u003cdiv className=\"nav\"\u003e\n    {children}\n  \u003c/div\u003e\n);\n\nconst Content = () =\u003e (\n  \u003cdiv className=\"content\"\u003emain content here\u003c/div\u003e\n);\n\nconst Sidebar = ({ children }) =\u003e (\n  \u003cdiv className=\"sidebar\"\u003e\n    {children}\n  \u003c/div\u003e\n);\n\n// Body 需要一个 sidebar 和 content， 但用这种形式写，\n// 他们可以是任何属性\nconst Body = ({ sidebar， content }) =\u003e (\n  \u003cdiv className=\"body\"\u003e\n    \u003cSidebar\u003e{sidebar}\u003c/Sidebar\u003e\n    {content}\n  \u003c/div\u003e\n);\n\nclass App extends React.Component {\n  state = {\n    user: {\n      avatar:\n        \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\"，\n      name: \"Dave\"，\n      followers: 1234，\n      following: 123\n    }\n  };\n\n  render() {\n    const { user } = this.state;\n\n    return (\n      \u003cdiv className=\"app\"\u003e\n        \u003cNav\u003e\n          \u003cUserAvatar user={user} size=\"small\" /\u003e\n        \u003c/Nav\u003e\n        \u003cBody\n          sidebar={\u003cUserStats user={user} /\u003e}\n          content={\u003cContent /\u003e}\n        /\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\nReactDOM.render(\u003cApp /\u003e， document.querySelector(\"#root\"));\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/mj19ywz0oy)\n\n如果你的 app 十分复杂(比这个例子复杂的多!)，可能很难使用`children`的模式。下面让我们将介绍如何使用 Redux 来避免 prop drilling。\n\n## Redux 示例\n\n我们先来看一下 Redux 的示例，再仔细观察 Context 是如何工作的。如果你对 Redux 并不熟悉，可以先阅读我写的[Redux 简介](https://daveceddia.com/how-does-redux-work/)(或者[观看视频](https://youtu.be/sX3KeP7v7Kg))。\n\n将上面的 app 用 Redux 重构后，`user`信息存储在 Redux store 中。这意味着我们可以使用 react-redux 的`connect`方法直接向组件中注入`user`属性。\n\n这样就实现了组件间的解耦。 `Nav`， `Body`和`Siderbar`不再接收和传递`user`属性。再也不需要接收无用的属性，再也不存在无用的耦合。\n\n其中的 reducer 也都十分简单。我在[Redux 中的 reducers 是如何工作的](https://daveceddia.com/what-is-a-reducer/)和[如何写出 immutable 代码](https://daveceddia.com/immutable-updates-react-redux/)中对这方面知识进行了更详细的介绍。\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\n// 我们需要 createStore, connect 和 Provider:\nimport { createStore } from \"redux\";\nimport { connect, Provider } from \"react-redux\";\n\n// 创建一个带有初始空 state 的 reducer\nconst initialState = {};\nfunction reducer(state = initialState, action) {\n  switch (action.type) {\n    // 响应 the SET_USER 并更新 state\n    case \"SET_USER\":\n      return {\n        ...state,\n        user: action.user\n      };\n    default:\n      return state;\n  }\n}\n\n// 利用 reducer 创建 store\nconst store = createStore(reducer);\n\n// 派发一个 action 来设置 user 的值\n// 因为初始化的 state 是空的\nstore.dispatch({\n  type: \"SET_USER\",\n  user: {\n    avatar: \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\",\n    name: \"Dave\",\n    followers: 1234,\n    following: 123\n  }\n});\n\n// mapStateToProps 方法从 state 中抽取了一个 key（user）\n// 并用`user`属性进行传递\nconst mapStateToProps = state =\u003e ({\n  user: state.user\n});\n\n// connect() 使 UserAvatar 可以直接接收 `user`\n// 而无需从父组件中接收\n\n// 还可以分割成两个变量：\n//   const UserAvatarAtom = ({ user, size }) =\u003e ( ... )\n//   const UserAvatar = connect(mapStateToProps)(UserAvatarAtom);\nconst UserAvatar = connect(mapStateToProps)(({ user, size }) =\u003e (\n  \u003cimg\n    className={`user-avatar ${size || \"\"}`}\n    alt=\"user avatar\"\n    src={user.avatar}\n  /\u003e\n));\n\n// connect() 使 UserStats 可以直接接收`user`\n// 而无需从父组件中接收\n// 两个组件可以使用同一个 mapStateToProps 方法\nconst UserStats = connect(mapStateToProps)(({ user }) =\u003e (\n  \u003cdiv className=\"user-stats\"\u003e\n    \u003cdiv\u003e\n      \u003cUserAvatar /\u003e\n      {user.name}\n    \u003c/div\u003e\n    \u003cdiv className=\"stats\"\u003e\n      \u003cdiv\u003e{user.followers} Followers\u003c/div\u003e\n      \u003cdiv\u003eFollowing {user.following}\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n));\n\n// Nav 不再需要知道 `user`\nconst Nav = () =\u003e (\n  \u003cdiv className=\"nav\"\u003e\n    \u003cUserAvatar size=\"small\" /\u003e\n  \u003c/div\u003e\n);\n\nconst Content = () =\u003e \u003cdiv className=\"content\"\u003emain content here\u003c/div\u003e;\n\n// Sidebar 不再需要知道 `user`\nconst Sidebar = () =\u003e (\n  \u003cdiv className=\"sidebar\"\u003e\n    \u003cUserStats /\u003e\n  \u003c/div\u003e\n);\n\n// Body 不再需要知道 `user`\nconst Body = () =\u003e (\n  \u003cdiv className=\"body\"\u003e\n    \u003cSidebar /\u003e\n    \u003cContent /\u003e\n  \u003c/div\u003e\n);\n\n// App 不再维护 state， 可以简化成一个无状态的函数\nconst App = () =\u003e (\n  \u003cdiv className=\"app\"\u003e\n    \u003cNav /\u003e\n    \u003cBody /\u003e\n  \u003c/div\u003e\n);\n\n// 将整个 app 用 Provider 包起来，使 connect()\n// 能够连接到 store\nReactDOM.render(\n  \u003cProvider store={store}\u003e\n    \u003cApp /\u003e\n  \u003c/Provider\u003e,\n  document.querySelector(\"#root\")\n);\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/943yr0qp3o)\n\n现在你也许想知道 Redux 是如何实现这种魔法的。这是个好问题，为什么 React 中不支持多层传递属性，而 Redux 就可以呢？\n\n答案是 Redux 使用了 React 中的 Context 功能。不过不是新的 Context API，而是老版本 Context。 React 文档中明确说明，除非是用于第三方库或明确知道自己在做什么，否则不推荐使用 Context。\n\nContext 就像是一个运行在组件身后的总线：如果你想从中接收电力（数据），只需要插上电源就可以了（React-Redux 的 `connect()`方法）。\n\n这部分功能只是 Redux 的冰山一角。自由传递属性只是 Redux 最**表面**的功能。除此之外，Redux 还有一些其他的优点：\n\n### 「纯」的`connect`\n\n`connect` 会自动使连接的组件变成「纯组件」，这也就意味着它们只有在 props 发生变化，也就是 Redux store 中对应的值发生变化时才会重新渲染。这防止了不必要的重新渲染，保证 app 可以快速运行。DIY 方法：创建一个继承 `PureComponent` 的类，或自己实现`shouldComponentUpdate`。\n\n### Redux 可以简化调试\n\nactions 和 reducers 的样板代码带来的一个好处就是强大的调试功能。\n\n使用 [Redux DevTools Extension](https://github.com/zalmoxisus/redux-devtools-extension) 可以帮助你自动记录 app 中的每一个 action。你可以在任何时候打开它，查看触发了哪些 actions，他们的 payload 是什么，以及 action 发生前后的 state 变化。\n\n![](/static/redux-devtools.gif)\n\nRedux DevTools 的另一个重要功能是时间旅行调试，也就是说你可以通过点击已发生的 action 跳转到该时间点，也就是重播在那之前的所有 actions（包含该 action 本身）。这是由于每个 action 都是 **immutably** 更新 state，因此你可以获取到 state 更新列表，并且无副作用的随意重播。\n\n还有像 [LogRocket](https://logrocket.com/) 这种的工具，可以在每一个用户的**产品环境**上提供始终开启的 Redux DevTools。收到了 bug 报告？没问题，在 LogRocket 中查找用户的会话，你就可以看到他们的操作记录和触发的 actions。这一切都是通过挖掘 Redux 的 action 流完成的。\n\n### 自定义 Redux 中间件\n\nRedux 支持**中间件**。中间件的意思是「每次派发 action 时都会执行的方法」。实现你自己的中间件并没有看起来那么难，而且能够完成许多强大的功能。\n\n例如：\n\n- 想要在 action name 是以 `FETCH_` 为前缀时，开始 API 请求？ 你可以用中间件来实现。\n- 想要在集中地将日志发送给分析软件？中间件是个不错的解决方案。\n- 想要在特定时间内阻止某些特定 actions 触发？你可以使用中间件来实现，不会对 app 的其余部分产生影响。\n- 想要自动地拦截带有 JWT token 的 action，并把他们存到 localStorage 中？没错，中间件。\n\n这里有一篇关于[如何写 Redux 中间件](https://medium.com/@jacobp100/you-arent-using-redux-middleware-enough-94ffe991e6)的文章。\n\n## \u003ca name=\"how-to-use-context-api\"\u003e\u003c/a\u003e如何使用 Context API\n\n但是也许你不需要 Redux 中那些花哨的功能。也许你不需要简单的调试，定制化，或性能提升，你只是希望数据的传递能变得简单些。也许你的 app 很小，或者需要先让某些功能正常工作后，再考虑引入一些其他的库。\n\nReact 的新 Context API 也许很适合你。让我们看看它是如何工作的。\n\n我在 Egghead 上发布了一个简短的 Context API 课程， 如果你们更喜欢看视频，可以参考[这里](https://egghead.io/lessons/react-pass-props-through-multiple-levels-with-react-s-context-api)。\n\nContext API 中有三个重要的部分：\n\n- `React.createContext` 生成 Context。\n- `Provider`（由`createContext`返回）创建贯穿整个组件树的「总线」。\n- `Consumer`（也是由`createContext`生成，接通「总线」以获取数据。\n\n这里的`Provider`和 React-Redux 里的`Provider`很像。接收任何形式的`value`属性（也可以是 Redux store，但是这样做很蠢）。大多数情况下都是包含一些数据和操作这些数据的方法的对象。\n\n而`Consumer`和 React-Redux 的`connect`方法有点像，接通数据并提供给组件。\n\n接下来是重点：\n\n```javascript\n// 首先，我们生成一个新的 Context\n// 这是一个包含了两个属性的对象: { Provider, Consumer }\n// 切记命名方式是帕斯卡式而不是驼峰式\n// 这十分重要，因为我们一会要把它用作一个组件\n// 组件名必须要以大写字母开始\nconst UserContext = React.createContext();\n\n// 需要数据的组件使用 Consumer 属性接通 context\n// Consumer 使用「render props」模式。\nconst UserAvatar = ({ size }) =\u003e (\n  \u003cUserContext.Consumer\u003e\n    {user =\u003e (\n      \u003cimg\n        className={`user-avatar ${size || \"\"}`}\n        alt=\"user avatar\"\n        src={user.avatar}\n      /\u003e\n    )}\n  \u003c/UserContext.Consumer\u003e\n);\n\n// 注意，我们不再是需要 user 属性\n// 因为 Consumer 可以从 context 中直接获取\nconst UserStats = () =\u003e (\n  \u003cUserContext.Consumer\u003e\n    {user =\u003e (\n      \u003cdiv className=\"user-stats\"\u003e\n        \u003cdiv\u003e\n          \u003cUserAvatar user={user} /\u003e\n          {user.name}\n        \u003c/div\u003e\n        \u003cdiv className=\"stats\"\u003e\n          \u003cdiv\u003e{user.followers} Followers\u003c/div\u003e\n          \u003cdiv\u003eFollowing {user.following}\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    )}\n  \u003c/UserContext.Consumer\u003e\n);\n\n// ... 其他组件 ...\n// ... 不在需要关注 `user` 属性\n\n// 最后，在 App 中，我们利用 Provider\n// 向下传递 context\nclass App extends React.Component\n  state = {\n    user: {\n      avatar:\n        \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\",\n      name: \"Dave\",\n      followers: 1234,\n      following: 123\n    }\n  };\n\n  render() {\n    return (\n      \u003cdiv className=\"app\"\u003e\n        \u003cUserContext.Provider value={this.state.user}\u003e\n          \u003cNav /\u003e\n          \u003cBody /\u003e\n        \u003c/UserContext.Provider\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/q9w2qrw6q4)\n\n让我们回顾一下它是如何工作的。\n\n记住一共三个部分： context 自身（由 `React.createContext` 创建），还有两个组件（`Provider` 和 `Consumer`）。\n\n### Provider 和 Consumer 是对应的\n\nProvider 和 Consumer 是绑定在一起的，不可分割。而且它们只知道如何与**对方**通信。如果你创建了两个不同的 contexts， 「Context1」和「Context2」，则 Context1 的 Provider 和 Consumer 无法与 Context2 的 Provider 和 Consumer 通信。\n\n### Context 不存储状态\n\n注意，context 自身**并没有自身的 state**。 它仅仅是数据的管道，向`Provider`中传入数据，传递到对应的`Consumer`中。\n\n当你在创建 context 时，可以像这样的传人「默认值」：\n\n```javascript\nconst Ctx = React.createContext(yourDefaultValue);\n```\n\n当 `Consumer` 上方没有 `Provider` 时，会使用默认值。如果不传的话， 默认值就是 `undefined`。 切记，这是**默认值**， 不是**初始**值。context 不保留任何值，只是传递你输入的数据。\n\n### Consumer 使用 Render Props 模式\n\nRedux 的 `connect` 是一个高阶组件（HoC），**封装**另一个组件，并且将值传递给它。\n\n相反的是，context 中的 `Consumer` 期望它的子组件是一个函数。 它在渲染时调用该函数，将从上层 `Provider` 中获取的值（或者是 context 的默认值，或者是 `undefined`）传进去。\n\n### Provider 只接收一个值\n\nProvider 只接收 `value` 属性。但传入的值可以是任何类型的。 如果你想传递多个值，你可以创建一个包含多个值的对象，并把该**对象**传递下去。\n\n以上就是 Context API 的大致内容了。\n\n## Context API 十分灵活\n\n因为创建 Context 会为我们提供两个可供自由使用的组件（Provier 和 Consumer）。下面是一些想法：\n\n### 将 Consumer 转化成高阶组件\n\n不想在每次使用时都添加 `UserContext.Consumer`？当然可以，这是你自己的代码！你已经成年了。\n\n如果你更喜欢通过属性的方式接收数据，可以对 `Consumer` 进行简单的封装，像这样：\n\n```javascript\nfunction withUser(Component) {\n  return function ConnectedComponent(props) {\n    return (\n      \u003cUserContext.Consumer\u003e\n        {user =\u003e \u003cComponent {...props} user={user} /\u003e}\n      \u003c/UserContext.Consumer\u003e\n    );\n  };\n}\n```\n\n还可以用 `withUser` 重写 `UserAvatar`：\n\n```javascript\nconst UserAvatar = withUser(({ size, user }) =\u003e (\n  \u003cimg\n    className={`user-avatar ${size || \"\"}`}\n    alt=\"user avatar\"\n    src={user.avatar}\n  /\u003e\n));\n```\n\nBOOM! 你可以像使用 Redux 的 `connect` 一样使用 context, 但是无法将组件自动变成「纯组件」。\n\n### 在 Provider 中维护 state\n\n还记得么， context 中的 Provider 只是一个传递数据的管道，无法维护任何数据。但你可以自己封装 Provider，来维护数据。\n\n在上面的例子中，我将数据都存储在 `App` 中，是为了帮助你更好地理解 Provider 和 Consumer。但是也许你想用生成一个自己的「store」。你可以自己创建一个维护和传递数据的组件：\n\n```javascript\nclass UserStore extends React.Component {\n  state = {\n    user: {\n      avatar:\n        \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\",\n      name: \"Dave\",\n      followers: 1234,\n      following: 123\n    }\n  };\n\n  render() {\n    return (\n      \u003cUserContext.Provider value={this.state.user}\u003e\n        {this.props.children}\n      \u003c/UserContext.Provider\u003e\n    );\n  }\n}\n\n// ... 跳过中间部分 ...\n\nconst App = () =\u003e (\n  \u003cdiv className=\"app\"\u003e\n    \u003cNav /\u003e\n    \u003cBody /\u003e\n  \u003c/div\u003e\n);\n\nReactDOM.render(\n  \u003cUserStore\u003e\n    \u003cApp /\u003e\n  \u003c/UserStore\u003e,\n  document.querySelector(\"#root\")\n);\n```\n\n现在 `UserStore` 唯一的职责就是维护 user 数据。太棒了， `App` 现在又是无状态组件，而且看起来更整洁了。\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/jpy76nm1v)\n\n### 使用 Context 传递 Actions\n\n通过 `Provider` 向下传递的对象中可以包含任何类型的数据，当然也就包括函数。你也可以叫「actions」。\n\n下面是一个简单的例子：一个简单的房间，还有一个开关来切换背景颜色-对不起，我是指灯光。\n\n![](/static/lightswitch-app.gif)\n\nstore 中不但包含灯光状态，还包含了切换灯光状态的函数，并且都将使用 context 向下传递。\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles.css\";\n\n// 空的 context\nconst RoomContext = React.createContext();\n\n// 本组件的唯一的职责：管理 Room 状态的组件\nclass RoomStore extends React.Component {\n  state = {\n    isLit: false\n  };\n\n  toggleLight = () =\u003e {\n    this.setState(state =\u003e ({ isLit: !state.isLit }));\n  };\n\n  render() {\n    // 向下传递 state 和 onToggleLight\n    return (\n      \u003cRoomContext.Provider\n        value={{\n          isLit: this.state.isLit,\n          onToggleLight: this.toggleLight\n        }}\n      \u003e\n        {this.props.children}\n      \u003c/RoomContext.Provider\u003e\n    );\n  }\n}\n\n// 从 RoomContext 接收 state 和控制函数\nconst Room = () =\u003e (\n  \u003cRoomContext.Consumer\u003e\n    {({ isLit, onToggleLight }) =\u003e (\n      \u003cdiv className={`room ${isLit ? \"lit\" : \"dark\"}`}\u003e\n        The room is {isLit ? \"lit\" : \"dark\"}.\u003cbr /\u003e\n        \u003cbutton onClick={onToggleLight}\u003eFlip\u003c/button\u003e\n      \u003c/div\u003e\n    )}\n  \u003c/RoomContext.Consumer\u003e\n);\n\nconst App = () =\u003e (\n  \u003cdiv className=\"app\"\u003e\n    \u003cRoom /\u003e\n  \u003c/div\u003e\n);\n\n// 将整个 App 包装在 RoomStore 中\n// 在 `App` 中包装也可以\nReactDOM.render(\n  \u003cRoomStore\u003e\n    \u003cApp /\u003e\n  \u003c/RoomStore\u003e,\n  document.querySelector(\"#root\")\n);\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/jvky9o0nvw)\n\n## 应该选择 Context 还是 Redux 呢\n\n现在你已经了解了它们的工作方式，你应该选择哪一个？**想清楚后再做决定**可以使你的 app 变得更好，写起来更有趣。我知道你也许只想要一个确定的「答案」，但我很遗憾的告诉你，「要视情况而定」。\n\n这依赖于 app 的大小，或将来的大小。将会有多少人进行开发 - 只有你，还是一个更大的团队？你或你的团队对于函数式的概念（Redux 依赖于此，像 immutability 和纯函数等）掌握如何？\n\n现在 JavaScript 生态系统中弥漫着一股竞争的气息，这是十分错误而且有害的。好像每一个选择都是零和博弈：如果你使用了**库 A**，那么你一定不能使用**它的竞争对手库 B**。当一个新的库发布时，一定在某种程度上比现有的库会更好一些，而且会将其取代。感觉所有的事情都是二选一，要么选择最好的，要么和过去的开发者一起退居幕后。\n\n将一系列选择看做工具箱会是一个更好的方案。像是选择用螺丝刀还是冲击起子。对于 80%的工作来说，冲击起子可以更快地固定螺丝。但对于另外的 20%，也许因为空间太小，或物品十分精致等原因，其实螺丝刀是一个更好的选择。当我得到冲击起子时，我不会立即丢弃螺丝刀，还有我的电钻。冲击起子无法**取代**其他的工具，它只是为我提供了另一个选项，另一个解决问题的方式。\n\nContext 完全不会「取代」Redux，就像 React 无法「取代」 Angular 或 jQuery。当我需要很快完成一些事情时，我还是会使用 jQuery。我有时还会使用服务器端渲染的 EJS 模板而不是启动一个完整的 React app。有时你的任务完全不需要 React 或 Redux 来完成。\n\n如今，当 Redux 的功能超过了你所需要的， 你可以选择 Context。\n\n- 原文地址：https://daveceddia.com/context-api-vs-redux/#how-to-use-the-react-context-api\n- 译文出自：TWNTF\n- 译者：Yingjian Li\n"}},"page":"/post","pathname":"/post","query":{"key":"redux-vs-context-api"},"buildId":"uGIiZVgp7uqY2aQyh8G2c","assetPrefix":"/next-blog","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/post" src="/next-blog/_next/static/uGIiZVgp7uqY2aQyh8G2c/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/next-blog/_next/static/uGIiZVgp7uqY2aQyh8G2c/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/next-blog/_next/static/uGIiZVgp7uqY2aQyh8G2c/pages/_error.js"></script><script src="/next-blog/_next/static/runtime/webpack-bb13cbd5f4cb95c0e1ff.js" async=""></script><script src="/next-blog/_next/static/chunks/commons.fe4372ab19016575274d.js" async=""></script><script src="/next-blog/_next/static/runtime/main-8c21d63e457d27dcf8e4.js" async=""></script></body></html>