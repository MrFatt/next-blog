<!DOCTYPE html><html style="height:100%" class="jsx-3241352696"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">Next-blog</title><link rel="preload" href="/next-blog/_next/static/_C0lHUbZafnHm5wwQ5b9U/pages/page.js" as="script"/><link rel="preload" href="/next-blog/_next/static/_C0lHUbZafnHm5wwQ5b9U/pages/_app.js" as="script"/><link rel="preload" href="/next-blog/_next/static/_C0lHUbZafnHm5wwQ5b9U/pages/_error.js" as="script"/><link rel="preload" href="/next-blog/_next/static/runtime/webpack-bf0647fcc5634d05e2c1.js" as="script"/><link rel="preload" href="/next-blog/_next/static/chunks/commons.fe83b0699cc115d8f2f1.js" as="script"/><link rel="preload" href="/next-blog/_next/static/runtime/main-8c21d63e457d27dcf8e4.js" as="script"/><style id="__jsx-821146791">a.jsx-821146791{margin-right:30px;font-size:20px;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;color:rgba(0,0,0,0.7);}</style><style id="__jsx-1769670723">header.jsx-1769670723{box-shadow:0 0 1px rgba(0,0,0,0.2);-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;}
.header-container.jsx-1769670723{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:0 auto;padding-top:20px;max-width:1000px;padding-bottom:20px;}
div.slogan.jsx-1769670723{display:inline-block;font-weight:bold;font-size:24px;font-family:"Oswald",sans-serif;}
a.jsx-1769670723{-webkit-text-decoration:none;text-decoration:none;cursor:pointer;color:rgba(0,0,0,0.7);}</style><style id="__jsx-1755787817">.card.jsx-1755787817{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;padding-top:10px;padding-bottom:15px;height:200px;width:100%;margin-right:40px;}
.post-overview.jsx-1755787817{padding-top:0;padding-bottom:0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}
.post-content.jsx-1755787817{overflow:hidden;line-height:23px;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:5;white-space:pre-wrap;-webkit-box-orient:vertical;}
.post-title.jsx-1755787817{font-size:24px;}
.read-more.jsx-1755787817{font-size:12px;}
a.jsx-1755787817{-webkit-text-decoration:none;text-decoration:none;cursor:pointer;color:rgba(0,0,0,0.7);}
a.jsx-1755787817:hover{color:blue;opacity:0.6;cursor:pointer;}</style><style id="__jsx-1081340487">ul{padding:0;}
.card-container{box-shadow:0 2px 1px -2px rgba(0,0,0,0.2);}
.card-container:last-child{box-shadow:0 2px 1px -2px rgba(0,0,0,0);}
li{list-style:none;}</style><style id="__jsx-1925800513">.jsx-1925800513{text-align:center;}
.page-number.jsx-1925800513{margin-right:15px;}
.page-number.jsx-1925800513:nth-child(1){cursor:text;}
.page-number.jsx-1925800513:nth-child(1):hover{color:black;}</style><style id="__jsx-1395599585">.sidebar-title.jsx-1395599585{padding-bottom:10px;font-size:large;box-shadow:0 2px 1px -2px rgba(0,0,0,0.2);}
.sidebar-tag.jsx-1395599585{padding-top:10px;}
a.jsx-1395599585{-webkit-text-decoration:none;text-decoration:none;cursor:pointer;color:rgba(0,0,0,0.7);}</style><style id="__jsx-3163762700">.home-container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;margin-top:20px;}
.content-with-pagination{margin-right:100px;}
.post-list-container{-webkit-flex:1 auto;-ms-flex:1 auto;flex:1 auto;}
.sidebar-container{min-width:150px;}</style><style id="__jsx-1732950521">.footer-container.jsx-1732950521{height:40px;margin-top:40px;background-color:black;}
.footer-content.jsx-1732950521{color:white;max-width:1000px;font-family:"Oswald",sans-serif;margin:10px auto;line-height:1.5;}
a.jsx-1732950521{margin-left:5px;color:white;}</style><style id="__jsx-2994019239">.jsx-2994019239{font-family:"Open Sans","Roboto","Microsoft YaHei","微软雅黑",STXihei, "华文细黑",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:auto;}
.content-container.jsx-2994019239{margin-top:50;-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}
.content.jsx-2994019239{margin:0 auto;max-width:1000px;height:100%;min-height:650px;}</style><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans:300,400,500" class="jsx-3241352696"/><link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet" class="jsx-3241352696"/><link href="/static/dracula.css" rel="stylesheet" class="jsx-3241352696"/><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" class="jsx-3241352696"></script><script class="jsx-3241352696">hljs.initHighlightingOnLoad();</script></head><body style="height:100%;margin:0" class="jsx-3241352696"><div id="__next"><div class="jsx-2994019239"><header class="jsx-1769670723"><div class="jsx-1769670723 header-container"><div class="jsx-1769670723 slogan"><a class="jsx-1769670723" href="/next-blog/page/?cur=1">Star Boy</a></div><div class="jsx-821146791"><a class="jsx-821146791" href="/next-blog/page/">Home</a><a class="jsx-821146791" href="/next-blog/about/">About</a></div></div></header><div class="jsx-2994019239 content-container"><div class="jsx-2994019239 content"><div class="jsx-3163762700 home-container"><div class="jsx-3163762700 content-with-pagination"><div class="jsx-1081340487 post-list-container"><ul class="jsx-1081340487"><div class="jsx-1755787817 card-container"><div class="jsx-1755787817 card"><div class="jsx-1755787817 post-overview"><a class="jsx-1755787817 post-title" href="/next-blog/post/goodbye-redux/"> [翻译]再见了, Redux</a><div class="jsx-1755787817 post-content">完整分析我们过去为什么需要 Redux，以及为什么我们不再需要它的原因。在过去的几年中，互联网技术已经向前端 JavaScript 框架转移，以提高 Web 和移动应用的用户体验。这太棒了 🔥，我个人十分喜欢这些框架的灵活性。 但是，太灵活了...为了真正理解出现这种情况的原因，让我们回拨一下时间，看看应用程序在 JavaScript 框架存在之前是如何构建的。在最初的几个前端框架（最著名的应该是 AngularJS， Backbone 和 Ember）出现之前，我们曾经在服务器端渲染模板，然后将整个 HTML 页面发送给浏览器。当时流行的框架包括：- Django(Python) — 2005 年 7 月 21 日正式发布；~距今 13 年。- Ruby on Rails — 2005 年 12 月 13 日正式发布； ~距今 13 年。- Symphony(PHP) — 2005 年十月 22 日正式发布； ~距今 13 年。这些框架的核心概念都是 MVC，也就是 Model-View—Controller 的应用开发结构。Models 是数据的『结构』，views 是『展示』数据的模板， controllers 负责将其『连接』。 这个时候当然也是有 JavaScript 的，只不过是一些像 jQuery 滑块以及一些实现弹跳动画的其他奇怪的库，这些都是完全没有必要的...总的来说，使用这些框架构建的 App 表现得相当不错，但还是会有一些问题。 然后有一天，Ryan Dahl 灵光一闪，不再仅仅将 JavaScript 作为完成动画效果的工具。他开发了第一版的 Node.js， 使得开发者能够在浏览器外以及服务器端使用 JavaScript。- Node.js — 2009 年 5 月 27 日正式发布；~距今 9 年。突然之间，人们开始意识到 Java</div><a class="jsx-1755787817 read-more" href="/next-blog/post/goodbye-redux/">Read more</a></div></div></div><div class="jsx-1755787817 card-container"><div class="jsx-1755787817 card"><div class="jsx-1755787817 post-overview"><a class="jsx-1755787817 post-title" href="/next-blog/post/react-native-at-airbnb-4/"> [翻译]Airbnb 的 React Native 实践： 弃用 React Native</a><div class="jsx-1755787817 post-content">由于大量的技术和组织问题,我们将弃用 React Native,并且今后将使用 Native 进行开发.这是我们介绍 React Native 经验和 Airbnb mobile 未来计划系列博客的第四篇.尽管已经有许多团队正在使用或计划使用 React Native 进行开发, 但是使用 React Native 却无法打到我们最初的目标.此外,我们还遇到了许多无法克服的技术和组织方面的问题,使得 React Native 的开发工作变得更加困难.因此,我们将弃用 React Native,并使用 Native 开发继续前进.如果 React Native 如预期一样工作, 开发将会十分迅速. 但是大量的技术和组织方面的问题,使许多项目产生了非预期的推迟.最近, 随着 React Native 的不断成熟以及积累</div><a class="jsx-1755787817 read-more" href="/next-blog/post/react-native-at-airbnb-4/">Read more</a></div></div></div><div class="jsx-1755787817 card-container"><div class="jsx-1755787817 card"><div class="jsx-1755787817 post-overview"><a class="jsx-1755787817 post-title" href="/next-blog/post/react-native-at-airbnb-5/"> [翻译]Airbnb 的 React Native 实践： 移动端发展计划</a><div class="jsx-1755787817 post-content">整装待发,重回原生这是我们介绍 React Native 经验和 Airbnb mobile 未来计划系列博客的第五篇虽然在使用 React Native 开发,但是我们也一直在积累原生开发的经验.现在我们已经一系列正在进行中或已完成的项目.其中,部分项目是受到 React Native 经验和最佳实践的启发而完成的.尽管不再使用 React Native, 我们仍然十分重视只写一次产品代码的价值. 我们仍然高度依赖我们的统一设计语言系统, 使许多 Android 和 iOS 的页面看起来完全一样.许多团队已经尝试了强大的服务器端渲染的框架,并且达成一致.在这些框架中,服务器将描述组件渲染,页面配置和相关操作的信息发送给移动设备.不同的移动平台获取到数据后使用 DLS 组件渲染原生页面或者整个流程.大规模服务器端渲染也存在着一些挑战. 下面是我们正在解决的一些问题:- 安全升级组件定义的同时维护向下兼容性.- 跨平台共享组件的类型定义.- 在运行时的事件响应,如点击按钮或用户输入- 多个 JSON 驱动页面间跳转的同时,维护内部状态.- 构建时没有实现的自定义组件的渲染.我们正在尝试使用Lona解决.服务器端渲染框架使我们能够更方便的进行试验以及热更新,为我们提供了巨大的价值.在 2016 年,我们开源了 Android 的Epoxy.Epoxy 可以实现简单的异构`RecyclerViews`, `UICollectionViews`和`UITableviews`.</div><a class="jsx-1755787817 read-more" href="/next-blog/post/react-native-at-airbnb-5/">Read more</a></div></div></div><div class="jsx-1755787817 card-container"><div class="jsx-1755787817 card"><div class="jsx-1755787817 post-overview"><a class="jsx-1755787817 post-title" href="/next-blog/post/redux-vs-context-api/"> 对比 Redux 和 Context API</a><div class="jsx-1755787817 post-content">React 在 16.3 版本中添加了一个新的 Context API， 「新」的意思是指之前的 Context API 是一个隐藏的功能。 由于在官方文档中并不鼓励使用 Context API， 大多数人都避免使用它，甚至都不知道它的存在。而现在 Context API 变成了 React 中的一等公民， 并且开放给了所有人(来自官方推广)。React 16.3 一发布， 网上的很多文章就因新 Context API 的出现，宣布「Redux 已死」。 然而如果你问过 Redux，我相信它会回答你:「那些言论都是夸大其词」。本文将会介绍新 Context API 是如何工作的， 它与 Redux 的相似之处， 什么时候应该选用 Context，以及为什么 Context 并不能完全取代 Redux。如果你只想大致了解 Context， 可以直接查看(现在，假设你已经清楚 React 的基础概念(props &amp; state)， 如果你还不清楚， 这里有一个免费的五天课程可以帮助你学习 React。让我们看一下这个大多数人会选择使用 Redux 的例子.我们首先从简单的纯 React 版本开始，再看一下如何使用 Redux，最后是 Context。这个 app 在两处地方显示用户的信息:一个是在导航栏的右上角，一个是在主要内容左侧的侧栏。(你也许注意到了， 这看起来很像 Twitter。这并非偶然！ 磨炼 React 技术最好的方法就是模仿(</div><a class="jsx-1755787817 read-more" href="/next-blog/post/redux-vs-context-api/">Read more</a></div></div></div><div class="jsx-1755787817 card-container"><div class="jsx-1755787817 card"><div class="jsx-1755787817 post-overview"><a class="jsx-1755787817 post-title" href="/next-blog/post/react-native-at-airbnb-3/"> [翻译]Airbnb 的 React Native 实践： 构建一个跨平台的移动端团队</a><div class="jsx-1755787817 post-content">React Native 转型这是 Airbnb 关于 React Native 经验分享和移动端未来计划系列文章的第三篇.除了数不尽的技术上的利弊, 我们还了解到 React Native 对工程团队的意义. 这远比向当前平台中添加一个新库或模式要复杂的多,我们在期间遭遇了许多组织上的挑战.与技术上的挑战不同,组织上的挑战更难发现,解决,恢复.谢天谢地,我们的 mobile 文化十分健全,但下面是在团队中使用 React Native 时需要注意的一些事项.根据我们的经验, 工程师们关于 React Native 有着完全不同的看法,有人认为它是统一了 Android,iOS 和 web 的银弹,有人则完全反对在团队中使用 React Native.即使是在使用之后,情况也十分类似,有的团队认为它是极好的,而有的人却感到失望并重新使用 native.在使用 React Native 时会有许多不可避免的 bug,改进和性能问题.但也还有许多不断变化的部分:1.  React Native 自身变化十分迅速2.  基础设施和功能的开发是同时进行的3.  React Native 对所有人来说都是一门新的技术,需要大家一起学习4.  我们的文档与调试指引有时会不一致,产生困惑因此,想要找到问题的根本原始通常是很困难的.有时无法确定问题是由哪个团队引起的还是 React Native 自身导致的.一个常见的误解就是 React Native 可以使你完全不用写原生代码.然而事实并非如此,有时你仍然需要写原生代码.例如,文本在不同平台上的渲染会有细微的差别,键盘的处理也有所不同以及在 Android 上 Activity 的重新创建和旋转等. 高质量的 React Native 应用需要仔细地平衡所有平台. 而</div><a class="jsx-1755787817 read-more" href="/next-blog/post/react-native-at-airbnb-3/">Read more</a></div></div></div></ul></div><div class="jsx-1925800513"><a class="jsx-1925800513 page-number" href="/next-blog/page/1/">1</a><a class="jsx-1925800513 page-number" href="/next-blog/page/2/">2</a></div></div><div class="jsx-1395599585 sidebar-container"><div class="jsx-1395599585 sidebar-title">Tags:</div><div class="jsx-1395599585 sidebar-tag"><a class="jsx-1395599585" href="/next-blog/tags/Redux/">Redux  (2)</a></div><div class="jsx-1395599585 sidebar-tag"><a class="jsx-1395599585" href="/next-blog/tags/React-Native/">React-Native  (5)</a></div><div class="jsx-1395599585 sidebar-tag"><a class="jsx-1395599585" href="/next-blog/tags/React/">React  (1)</a></div></div></div></div></div><footer style="flex:0 0 auto" class="jsx-1732950521"><div class="jsx-1732950521 footer-container"><div class="jsx-1732950521 footer-content">© 2018 Yingjian Li. Powered by:<a href="https://nextjs.org/" class="jsx-1732950521">Next.js</a>. Inspired by<a href="https://github.com/frostfan/hexo-theme-polarbear" class="jsx-1732950521">Polar Bear</a></div></div></footer></div></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"posts":[{"key":"goodbye-redux","content":"| date       | tag   |\n| ---------- | ----- |\n| 2018-09-18 | Redux |\n\n---\n\n# [翻译]再见了, Redux\n\n_完整分析我们过去为什么需要 Redux，以及为什么我们不再需要它的原因。_\n\n在过去的几年中，互联网技术已经向前端 JavaScript 框架转移，以提高 Web 和移动应用的用户体验。这太棒了 🔥，我个人十分喜欢这些框架的灵活性。\n\n\u003e 但是，太灵活了...\n\n为了真正理解出现这种情况的原因，让我们回拨一下时间，看看应用程序在 JavaScript 框架存在之前是如何构建的。\n\n## ⏳，在 JavaScript 之前\n\n在最初的几个前端框架（最著名的应该是 AngularJS， Backbone 和 Ember）出现之前，我们曾经在服务器端渲染模板，然后将整个 HTML 页面发送给浏览器。当时流行的框架包括：\n\n![](/static/template-frameworks.png)\n\n- Django(Python) — 2005 年 7 月 21 日正式发布；~距今 13 年。\n- Ruby on Rails — 2005 年 12 月 13 日正式发布； ~距今 13 年。\n- Symphony(PHP) — 2005 年十月 22 日正式发布； ~距今 13 年。\n\n这些框架的核心概念都是 MVC，也就是 Model-View—Controller 的应用开发结构。Models 是数据的『结构』，views 是『展示』数据的模板， controllers 负责将其『连接』。\n\n\u003e 这个时候当然也是有 JavaScript 的，只不过是一些像 jQuery 滑块以及一些实现弹跳动画的其他奇怪的库，这些都是完全没有必要的...\n\n总的来说，使用这些框架构建的 App 表现得相当不错，但还是会有一些问题。 然后有一天，Ryan Dahl 灵光一闪，不再仅仅将 JavaScript 作为完成动画效果的工具。他开发了第一版的 Node.js， 使得开发者能够在浏览器外以及服务器端使用 JavaScript。\n\n- Node.js — 2009 年 5 月 27 日正式发布；~距今 9 年。\n\n突然之间，人们开始意识到 JavaScript 强大的功能，只需要一点点代码就可以完成大量的工作。这也让其他开发者了解到了 JavaScript 的可能性。人们不仅开始为 Node.js 构建更多强大的工具，同时还开始创造有趣的前端框架。未来几年中 JavaScript 发展的雪球就是从这时开始的。\n\n![](/static/node-frameworks.png)\n\n- Express.js(后端） — 2010 年 11 月 16 日正式发布； ~距今 8 年。\n- Backbone.js(前端） — 2010 年 10 月 12 日正式发布； ~距今 8 年。\n- AngularJS(前端） — 2010 年 10 月 20 日正式发布； ~距今 8 年。\n- Ember.js(前端） — 2011 年 12 月 8 日正式发布； ~距今 7 年。\n\n这使得 App 开发的方式发生了重大转变。之前完全由服务器进行处理的 MVC 结构被分成了两部分——处理 MC（models 和 controllers）的服务器，以及使用上述 JavaScript 框架处理 view 的前端客户端。在一些早期的框架中，view 中仍然包含 models 和 controllers。两份 model 和 controllers，有些在前端，有些在后端 — 听起来需要很多的代码。🙇🏽‍\n\n## 🤦‍，Facebook 的问题\n\n每个人都很开心。一切都正常运行而且易于理解，只需要花费几个小时来学习。\n\n\u003e 然后情况发生了变化\n\nFacebook 迅速发展，成为了全球最大的 web 应用。你可以想象，作为最大的 web 应用会遇到很多的挑战。其中最头痛的就是如何在页眉中正确展示通知的数量。\n\n![](/static/facebook-notifications.jpeg)\n\n随着人们大量的使用 Facebook 应用，人们期望应用中的通知应该能够正确更新。但通常情况下却不是这样的。我不清楚你是否在那个时候使用过 Facebook 或者是否还记得，但是这些通知经常是错的... 问题出在对于 web 应用来说很难识别出应用中某一部分的改变（阅读消息）并且影响应用的另一部分（减少未读消息数）。\n\n这并不是最糟糕的事 — 这可以通过重载页面来解决 — 但 Facebook 拥有超过 1000 个充满热情的员工，并决定是时候做些事情了。因此他们重新思考了前端框架如何处理信息并且决定创造一个他们自己的前端框架；React。\n\n- React（前端） — 2013 年 3 月正式发布； ~距今 5 年。\n\n这个新框架在渲染 HTML 方面的表现十分出色，而且十分原始，没有很多关于『如何』开发应用方面的内容。同样地，他们还发布了 Flux，最终发展成了 Redux（Redo-Flux）。下面是 Flux 网站上 2014/2015 年的视频。[这个视频](https://youtu.be/nYkdrAPrdcw)主要讲解 Flux 和 React。\n\n## 🍐...两者结合了\n\nRedux 的工作方式是将应用中所有的动态信息存储到一个 JavaScript 对象中。当应用中的某部分需要展示数据时，它需要向服务器请求信息，更新 JavaScript 对象，最后将数据展示给用户。将所有信息存储到一个地方，应用总能正确地展示信息。因此解决了 Facebook 的通知问题。\n\n突如其来地，React Redux 成为了构建应用的一个新框架。Facebook 努力解决了他们的问题，而且大家都很开心，对不对？\n\n✋**并不。**\n\n问题是，大家（包括我）开始使用一个对象存储所有的信息 — 服务器提供的全部数据。这确实可以维护所欲数据的最新状态，但是也有下面的三个问题：\n\n1. 需要花费**大量的**额外代码，这将花费你的大部分**时间**。\n2. 将所有代码放到一个地方，也会带来『数据过期』的问题，也就是说应用中可能出现来自之前状态的过期数据。\n3. 对于新开发者来说，学习曲线陡峭，新手前端 web 开发人员很难采用这种技术。\n\n如果我们设法将一个向用户展示数据的简单任务，从 2005 年的 MVC 框架中的模板迁移到现在的大型前端应用中，那么前端代码量是后端的 10 倍。例如我最近开发了一个简单的应用，并用[WakaTime](https://wakatime.com/)来测量我编程的时间。结果如下：\n\n- React Redux 前端代码库 — 32 小时。\n- Express + Mongoose 后端代码库 — 4 小时。\n\n认真的吗？？🤯 我在前端代码上花费的时间是后端的 8 倍。让我们来看看为什么会需要这么多的代码。下面是我在前端代码库中添加基本的信息抓取请求时，需要的步骤：\n\n```\n🚧 警告：下面的内容技术性较强，请自由阅读。\n```\n\n1. 创建一个组件来展示用户列表（没有任何问题）。\n2. 创建一个`fetch`请求 API。\n3. 在 state 中添加新字段。\n4. 添加一个更新 state 中数据的 action。\n5. 添加一个 thunk 方法，来执行 `fetch` 并且用 action 来更新 state。\n6. 使用 `connect()` 将 thunk 方法添加到组件中。\n7. 再次使用 `connect()`，从 Redux state 中抽取数据。\n8. 在组件的属性类型中声明 thunk 方法和抽取的数据。\n9. 在 `componentDidMount()` 中调用 thunk 方法。\n10. 最终在 DOM 中渲染数据。\n\n我的老天鹅...10 步...想当年使用 Ruby on Rails 的时候，我只需要把数据传给 HTML 就可以了。最后的结果是完全一样的。我意识到是时候做出一些改变了。\n\n## ☝️，一个新方案\n\nRedux 在解决前端应用同步的问题上十分出色，但是也带来一些其他的问题（像上面提到的）。仔细思考一下，Redux 给我们带来了什么额外的功能？\n\n\u003e 本质上来说，我们只是解决了一些不重要的问题。\n\nFacebook 也已经注意到了这一点，并且开始使用 GraphQL 这样的新技术来解决这个问题。GraphQL 在当时是一个时髦的词，但我不清楚大家是否真的知道其中的**原因**。\n\nGraphQL 与 Redux **完全**不同。Facebook 再一次推出了一款令人惊叹的产品，但是没能表述清楚为什么这款产品如此重要；所以我需要花费几分钟说明一下上下文。\n\n\u003e 总的来说，GraphQL 是汽车而 Redux 是马。\n\n**什么？Redux 怎么会是马？**\n\n我将两种技术描述成马和汽车的原因是；你不可能认为马和汽车是相似的 — 一个是四条腿的动物而另一个是装着轮子的机器。然而他们的最终目的都相同，都是将人送到终点。汽车在公路上行驶并需要燃料，然而马可以跨过岩石。他们各自的优势不同，适用场景也不同，但一般来说；汽车比马要快。\n\n**那么，GraphQL 是什么**\n\n官方文档将 GraphQL 描述为『GraphQL 是 API 的查询语言』十分模糊。本质上说，这里查询语言的意思是将一个 API 替换成了上百个 HTTP 端点。因为这个技术目前还不成熟，文档和支持还是有些难理解；也就是说还有一定的学习曲线。下面是一个例子。\n\nGraphQL 将会替代下面的端点：\n\n- GET `/user/1234567890`\n- POST `/cars`\n- PUT `/examples/endpoints`\n\n还有只查询所需信息的自定义的查询，例如：\n\n```\n{\n  user(id: \"1234567890\") {\n    name,\n    email\n  }\n}\n```\n\n将会返回：\n\n```\n{\n  \"user\": {\n    \"name\": \"Luke Skywalker\",\n    \"email\": \"luke@iamyourfather.com\"\n  }\n}\n```\n\n等一下 — 自定义查询... 岂不是需要花很长时间来实现。 ~那只是你的想法\n\n事实并非如此。原因是；当只请求需要的数据时，不再需要生成那么多的服务器请求，也就意味着你不需要写那么多的代码来处理这些请求。因此，您最终会在不必实现的代码上节省大量时间。\n\n**🤷‍ 但这如何取代 Redux 呢？**\n\n又一个好问题，感谢提问。简单来说，**不会取代** Redux。然而它却*鼓励*你*不要*将所有信息存在 Redux 提供的对象中。这是因为自定义查询不是为整个应用设计的，而是为特定部分设计的。在应用程序范围的数据源中存储特定部分的数据是一种反模式（也不符合逻辑）。\n\n\u003e 通过 GraphQL，可以减少对 Redux 的依赖，进而减少大量不必要的代码。\n\n还值得注意的是；Redux 和 GraphQL 可以在一个应用中共存。这对于现有的 Redux 应用中集成 GraphQL 来说很有帮助。下面是关于如何实现的[文档](https://s3.amazonaws.com/apollo-docs-1.x/redux.html)。\n\n在解决小问题时，Redux 成为了一个备选项。你可以选择使用它，但这同时会增加开销并引入其他问题，或者你也可以选择使用其他技术。\n\n**好的，那么我们用什么技术呢？**\n\n当时，Redux 是解决问题的好办法。但是随着 Web 开发的发展突飞猛进，web socket 领域也随之不断发展。\n\nWeb socket 是客户端与服务端间开放的连接，所以服务端可以通知客户端何时进行特定的更新。你猜怎么着？GraphQL 以订阅的形式直接支持 Web socket。因此，我们可以使用订阅来更新我们应用中希望保持同步的部分。\n\n这其中最大的区别是；不在需要客户端来通知我们某些组件需要更新（通过 Redux），而是我们的服务器通知客户端来更新数据。这两种方式的结果是一样的。下面是使用 MongoDB 和 Mongoose 实现 web socket 或订阅的例子。\n\n[A Node.js Perspective on MongoDB 3.6: Change Streams](http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-change-streams.html)\n\n[Mongoose v5.2.13: API docs](https://mongoosejs.com/docs/api.html#model_Model.watch)\n\n## 🚀，未来看起来很美好！\n\nGraphQL 已经开发了一段时间，但现在处于可以在生产中使用的阶段。坦白的说，它的文档非常难以理解，需要事先了解 JavaScript 以及服务器的工作方式。但是，如果你还不是很清楚 - 至少你知道目标是什么。这是一个常用教程的[链接](https://graphql.org/learn/)。\n\n还有许多有用的库可以帮助你完成 GraphQL 的集成工作。别担心，你不必一次性的完成所有工作，这些库可以帮助你逐渐完成迁移。[Apollo](https://www.apollographql.com/) 是在这方便做的相当不错的一家公司。\n\n就是这样。我希望这篇文章对于你理解这些复杂的概念有所帮助。\n\n如果你喜欢这篇文章，你可以**鼓鼓掌** — 这对我来说很重要 — 或者如果你有任何的问题，欢迎留言！\n\n谢谢！🙌\n\n你也可以关注我的[推特](https://twitter.com/jacrobsco) 🦉 或者... 看看我其他的博客：\n\n- [Startup Productivity Guide 101](https://medium.com/@jackrobertscott/startup-productivity-guide-101-85afdcf463fc)\n- [How I Launched a Startup in 4 Days](https://medium.com/@jackrobertscott/startup-validation-done-right-6c7c62229e9)\n- [Getting Your First 100 Startup Customers](https://medium.com/@jackrobertscott/getting-your-first-100-startup-customers-8cafd0ee8e7d)\n\n* 原文地址：https://hackernoon.com/goodbye-redux-26e6a27b3a0b\n* 译文出自：TWNTF\n* 译者：Yingjian Li\n"},{"key":"react-native-at-airbnb-4","content":"| date       | tag          |\n| ---------- | ------------ |\n| 2018-08-14 | React-Native |\n\n---\n\n# [翻译]Airbnb 的 React Native 实践： 弃用 React Native\n\n\u003e 由于大量的技术和组织问题,我们将弃用 React Native,并且今后将使用 Native 进行开发.\n\n_这是我们介绍 React Native 经验和 Airbnb mobile 未来计划[系列博客](https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c)的第四篇_.\n\n尽管已经有许多团队正在使用或计划使用 React Native 进行开发, 但是使用 React Native 却无法打到我们最初的目标.此外,我们还遇到了许多无法克服的[技术](https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838)和[组织](https://medium.com/airbnb-engineering/building-a-cross-platform-mobile-team-3e1837b40a88)方面的问题,使得 React Native 的开发工作变得更加困难.\n\n因此,我们将弃用 React Native,并使用 Native 开发继续前进.\n\n## 无法达到目标\n\n### 开发速度\n\n如果 React Native 如预期一样工作, 开发将会十分迅速. 但是大量的[技术](https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838)和[组织](https://medium.com/airbnb-engineering/building-a-cross-platform-mobile-team-3e1837b40a88)方面的问题,使许多项目产生了非预期的推迟.\n\n### 代码质量\n\n最近, 随着 React Native 的不断成熟以及积累的经验不断增多,我们能够完成一些曾经不确定是否可行的事情.我们实现了`共享元素转换(shared element transitions)`,`视差特效(parallax)`以及掉帧的性能优化等. 然而,某些技术问题(如初始化和异步渲染等)导致某些功能很难实现,内外部资源的匮乏也增加了开发的难度.\n\n### 一次编码到处运行\n\n虽然 React Native 的特性几乎都是跨平台的,我们的 app 中也只有小部分使用 React Ntive.此外,还需要大量的桥接基础设施来确保产品工程师能够高效地工作.结果导致我们需要维护三个平台的代码.我们也许可以在 mobile 端和 web 端可以共享代码或 npm 包,但却没有找到恰当的实现方式.\n\n### 提升开发体验\n\nReact Native 的开发体验参差不齐.在某些方面(如构建时间)表现的很好.而在其他方面(如调试)则表现的很糟糕.具体细节的介绍在本系列的第二部分中.\n\n## 弃用计划\n\n由于 React Native 无法帮助我们达到一些特定的目标,我们决定弃用 React Native.我们目前正在与团队一起制定健全的过渡计划.我们已经停止了所有的 React Native 新功能的开发,并且计划在今年年底之前把最常使用的页面过渡到 native.这也受益于事先计划好的重新设计.我们的 native 基础设施团队将会持续支持 React Native 直到 2018 年.在 2019 年,我们将逐渐减少对 React Native 的支持,开始减少 React Native 的开销,如启动时的 runtime 初始化.\n\n在 Airbnb,我们拥抱开源.我们积极地使用和贡献全世界许多的开源项目,而且也开源了我们一部分的 React Native 工作.由于我们不再会使用 React Native,我们也无法继续维护我们的 React Native 仓库和社区.考虑到社区,我们将会吧我们 React Native 的开源工作迁移到[react-native-community](https://github.com/react-native-community),我们已经开始着手[react-native-maps](https://github.com/react-community/react-native-maps)的迁移工作了,后续还会继续迁移[react-navigation](https://github.com/airbnb/native-navigation)和[lottie-react-native](https://github.com/airbnb/lottie-react-native/).\n\n## React Native 并非一无是处\n\n尽管 React Native 无法满足我们的需求,但是使用过 React Native 的工程师通常都认为体验不错.在这些工程师中:\n\n- 60%表示鹅妹子嘤\n- 20%认为还不错\n- 15%稍有不满\n- 5%强烈不满\n\n63%的工程表示如果有机会的话还会选择 React Native,74%会考虑在新项目中使用 React Native.值得注意的是，这些结果存在固有的选择偏差，因为它只选择使用过 React Native 的人进行调查。\n\n这些工程师写了 80000 行产品代码,220 个页面以及 40000 行 javascript 基础设施.作为参考,在每个 native 平台上,我们拥有大概 10 倍的代码量以及 4 倍的页面.\n\n## React Native 正在逐渐成熟\n\n这一系列文章说明了我们目前的 React Native 经历.但是 Facebook 和广大的 React Native 社区正专注于使 React Native 能大规模地应用到混合 App 中.React Native 正以最快速度发展.去年一共有超过 2500 个提交,而且 Facebook[刚刚宣布](https://facebook.github.io/react-native/blog/2018/06/14/state-of-react-native-2018)他们正在解决我们直面的技术问题.即使我们不在使用 React Native,我们仍会关注这部分工作.\n\n## 写在最后\n\n我们把 React Native 集成到了快速大型 App 中,并且持续快速的开发.我们遇到的许多问题是由我们采用的混合方案引起的.我们的规模允许我们承担并且解决这些问题,但小公司可能没有时间来解决这些问题.使 React Native 与 native 无缝连接是有可能的但是十分具有挑战性.每一个使用 React Native 的公司都会有自己独特的经历(团队构成,App,产品需求和 React Native 成熟度等).\n当把迭代速度,质量,开发体验等一系列因素综合起来考虑 React Native 是否达到或超过了我们的目标和预期时,很多时候我们都感觉像是在颠覆移动开发的边缘.即使这种经历是振奋人心的,当我们在平衡好处和痛点,以及目前团队的需求和资源时,我们认为我们不再需要 React Native.\n\n是否使用一个新平台是一个重大的决定,而且完全取决于你的团队情况.我们的经历和退出的原因也许并不适用于你的团队.事实上,[许多公司](https://instagram-engineering.com/react-native-at-instagram-dd828a9a90c7)还在继续成功地使用 React Native,而且 React Native 对许多其他公司而言可能仍然是最佳选择.\n\n尽管我们从来没有停止过 native 的研发,弃用 React Native 释放了许多资源,可以使 native 发展的更好.下一篇将介绍我们 native 的新计划.\n\n_这是 Airbnb 关于 React Native 经验分享和移动端未来计划系列文章的第四篇._\n\n[第一篇: React Native at Airbnb](../react-native-at-airbnb-1)\n\n[第二篇: The Technology](../react-native-at-airbnb-2)\n\n[第三篇: Building a Cross-Platform Mobile Team](../react-native-at-airbnb-3)\n\n[第四篇: Making a Decision on React Native](../react-native-at-airbnb-4)\n\n[第五篇: What's Next for Mobile](../react-native-at-airbnb-5)\n\n- 原文地址：https://medium.com/airbnb-engineering/sunsetting-react-native-1868ba28e30a\n- 译文出自：TWNTF\n- 译者：Yingjian Li\n"},{"key":"react-native-at-airbnb-5","content":"| date       | tag          |\n| ---------- | ------------ |\n| 2018-08-11 | React-Native |\n\n---\n\n# [翻译]Airbnb 的 React Native 实践： 移动端发展计划\n\n\u003e 整装待发,重回原生\n\n_这是我们介绍 React Native 经验和 Airbnb mobile 未来计划[系列博客](https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c)的第五篇_\n\n## 激动人心的时刻即将来临\n\n虽然在使用 React Native 开发,但是我们也一直在积累原生开发的经验.现在我们已经一系列正在进行中或已完成的项目.其中,部分项目是受到 React Native 经验和最佳实践的启发而完成的.\n\n### 服务器端渲染\n\n尽管不再使用 React Native, 我们仍然十分重视只写一次产品代码的价值. 我们仍然高度依赖我们的统一设计语言系统, 使许多 Android 和 iOS 的页面看起来完全一样.\n\n许多团队已经尝试了强大的服务器端渲染的框架,并且达成一致.在这些框架中,服务器将描述组件渲染,页面配置和相关操作的信息发送给移动设备.不同的移动平台获取到数据后使用 DLS 组件渲染原生页面或者整个流程.\n\n大规模服务器端渲染也存在着一些挑战. 下面是我们正在解决的一些问题:\n\n- 安全升级组件定义的同时维护向下兼容性.\n- 跨平台共享组件的类型定义.\n- 在运行时的事件响应,如点击按钮或用户输入\n- 多个 JSON 驱动页面间跳转的同时,维护内部状态.\n- 构建时没有实现的自定义组件的渲染.我们正在尝试使用[Lona](https://github.com/airbnb/Lona/)解决.\n\n服务器端渲染框架使我们能够更方便的进行试验以及热更新,为我们提供了巨大的价值.\n\n### Epoxy 组件\n\n在 2016 年,我们开源了 Android 的[Epoxy](https://github.com/airbnb/epoxy).Epoxy 可以实现简单的异构`RecyclerViews`, `UICollectionViews`和`UITableviews`. 如今大多数的新页面都使用 Epoxy. 这使得我们可以将每个页面分解成独立的组件,进而实现懒加载. 而且在 iOS 和 Android 上均可使用.\niOS 端示例代码:\n\n```swift\nBasicRow.epoxyModel(\n  content: BasicRow.Content(\n    titleText: \"Settings\",\n    subtitleText: \"Optional subtitle\"),\n  style: .standard,\n  dataID: \"settings\",\n  selectionHandler: { [weak self] _, _, _ in\n    self?.navigate(to: .settings)\n  })\n```\n\n在 Android 上,我们利用[DSLs in Kotlin](https://kotlinlang.org/docs/reference/type-safe-builders.html),使得组件的实现变得简单而且类型安全:\n\n```kotlin\nbasicRow {\n id(\"settings\")\n title(R.string.settings)\n subtitleText(R.string.settings_subtitle)\n onClickListener { navigateTo(SETTINGS) }\n}\n```\n\n### Epoxy 中的 diffing\n\n在 React 中,[render](https://reactjs.org/tutorial/tutorial.html#what-is-react)会返回一个组件的列表.React 性能的关键是组件仅仅是真实 DOM 的数据模型.对组件树进行 diff,然后只更新改动部分.我们在 Epoxy 中引入了相似的概念.在 Epoxy 中,在[buildModels](https://reactjs.org/tutorial/tutorial.html#what-is-react)中声明整个页面的模型,再加上 Kotlin DSL,使得它在概念上与 React 十分相似,示例代码:\n\n```kotlin\noverride fun EpoxyController.buildModels() {\n  header {\n    id(\"marquee\")\n    title(R.string.edit_profile)\n  }\n  inputRow {\n    id(\"first name\")\n    title(R.string.first_name)\n    text(firstName)\n    onChange {\n      firstName = it\n      requestModelBuild()\n    }\n  }\n  // 其余的模型放在这里\n}\n```\n\n每当你的数据发生变化,调用`requestModelBuild()`将会调用最佳的`RecyclerView`来重新渲染你的页面.\n\niOS 端的示例代码:\n\n```swift\noverride func itemModel(forDataID dataID: DemoDataID) -\u003e EpoxyableModel? {\n  switch dataID {\n  case .header:\n    return DocumentMarquee.epoxyModel(\n      content: DocumentMarquee.Content(titleText: \"Edit Profile\"),\n      style: .standard,\n      dataID: DemoDataID.header)\n  case .inputRow:\n    return InputRow.epoxyModel(\n      content: InputRow.Content(\n        titleText: \"First name\",\n        inputText: firstName)\n      style: .standard,\n      dataID: DemoDataID.inputRow,\n      behaviorSetter: { [weak self] view, content, dataID in\n        view.textDidChangeBlock = { _, inputText in\n          self?.firstName = inputText\n          self?.rebuildItemModel(forDataID: .inputRow)\n        }\n      })\n  }\n}\n```\n\n### 一个全新的 Android 产品框架(MvRx)\n\n在近期开发中,最令人兴奋的是一个正在开发的新框架,我们内部叫做 MvRx.MvRx 结合了`Epoxy`,[`Jetpack`](https://developer.android.com/jetpack/),[`RxJava`](https://github.com/ReactiveX/RxJava)和`Kotlin`的优点,以及一些 React 中的规则,使得构建新页面变得更加简单,更加流畅.它是由常见的开发模式以及 React 中的优点开发的,是一个\"固定\"([opinionated](https://stackoverflow.com/questions/802050/what-is-opinionated-software))但灵活的框架.它也是线程安全的，几乎所有东西都不在主线程运行，这使得滚动和动画感觉流畅.\n\n到目前为止,它已经应用到了大量的页面中,并且几乎完全不需要处理生命周期.我们目前正在一些 Android 产品上进行试验,并且如果一切顺利的话会将他开源.下面是创建一个发出网络请求的功能页面所需的全部代码:\n\n```Kotlin\ndata class SimpleDemoState(val listing: Async\u003cListing\u003e = Uninitialized)\n\nclass SimpleDemoViewModel(override val initialState: SimpleDemoState) : MvRxViewModel\u003cSimpleDemoState\u003e() {\n    init {\n        fetchListing()\n    }\n\n    private fun fetchListing() {\n        // This automatically fires off a request and maps its response to Async\u003cListing\u003e\n        // which is a sealed class and can be: Unitialized, Loading, Success, and Fail.\n        // No need for separate success and failure handlers!\n        // This request is also lifecycle-aware. It will survive configuration changes and\n        // will never be delivered after onStop.\n        ListingRequest.forListingId(12345L).execute { copy(listing = it) }\n    }\n}\n\nclass SimpleDemoFragment : MvRxFragment() {\n    // This will automatically subscribe to the ViewModel state and rebuild the epoxy models\n    // any time anything changes. Similar to how React's render method runs for every change of\n    // props or state.\n    private val viewModel by fragmentViewModel(SimpleDemoViewModel::class)\n\n    override fun EpoxyController.buildModels() {\n        val (state) = withState(viewModel)\n        if (state.listing is Loading) {\n            loader()\n            return\n        }\n        // These Epoxy models are not the views themself so calling buildModels is cheap. RecyclerView\n        // diffing will be automaticaly done and only the models that changed will re-render.\n        documentMarquee {\n            title(state.listing().name)\n        }\n        // Put the rest of your Epoxy models here...\n    }\n\n    override fun EpoxyController.buildFooter() = fixedActionFooter {\n        val (state) = withState(viewModel)\n        buttonLoading(state is Loading)\n        buttonText(state.listing().price)\n        buttonOnClickListener { _ -\u003e }\n    }\n}\n```\n\nMvRx 具有简单的构造,用于处理 Fragment 参数,跨进程重启时`savedInstanceState`的持久化,TTI 追踪以及一些其他的功能.\n\n我们也正在开发一个相似的 iOS 框架,该框架目前正处于早期测试阶段.\n\n尽管我们已经对目前所取得的进展十分满意了,还是希望很快可以听到更多相关的消息.\n\n### 迭代速度\n\n当从 React Native 切换回原生时,迭代速度是显而易见的问题.测试改动的时间从原本只需要 1~2 秒,变成可能需要等待将近 15 分钟是不可接受的.幸运的是,我们能够从一些方面缓解这一现象.\n\n我们在 Android 和 iOS 上构建的基础设施能够根据功能模块编译启动器和部分 app.\n\n在 Android 端使用了[gradle 产品风格](https://developer.android.com/studio/build/build-variants#product-flavors), 我们的 gradle 模块如下图所示:\n\n![](/static/gradle%20modules.png)\n\n新的间接层使得工程师可以 app 的切片上进行开发.再配合[Intellij module unloadinig](https://blog.jetbrains.com/idea/2017/06/intellij-idea-2017-2-eap-introduces-unloaded-modules/),可以在 Macbook Pro 上动态提高构建和 IDE 的性能.\n\n我们已经构建了用于创建新的测试 flavor 的脚本,并且在短短几个越能,我们已经完成了超过 20 个.使用这些新风格可以使开发构建提速 2.5 倍,并且超过 5 分钟的比例下降了 15 倍.\n\n作为参考,这是用于动态生成具有根依赖性模块产品风格的[gradle 代码块](https://gist.github.com/gpeal/d68e4fc1357ef9d126f25afd9ab4eee2).\n\n相似地,iOS 上的模块如下图所示:\n\n![](/static/iOS%20modules.png)\n\n同样系统的构建速度会提升 3-8 倍.\n\n## 结论\n\n很高兴能够成为一家不怕尝试新技术但又努力保持高质量,高速度和开发体验的公司.最后,React Native 是发布功能,为我们提供了新的移动开发思路的重要工具.如果这听起来像是您想参与的旅程，[请告诉我们](https://www.airbnb.com/careers/departments/engineering)！\n\n_这是 Airbnb 关于 React Native 经验分享和移动端未来计划系列文章的第五篇._\n\n[第一篇: React Native at Airbnb](../react-native-at-airbnb-1)\n\n[第二篇: The Technology](../react-native-at-airbnb-2)\n\n[第三篇: Building a Cross-Platform Mobile Team](../react-native-at-airbnb-3)\n\n[第四篇: Making a Decision on React Native](../react-native-at-airbnb-4)\n\n[第五篇: What's Next for Mobile](../react-native-at-airbnb-5)\n\n- 原文地址：https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab\n- 译文出自：TWNTF\n- 译者：Yingjian Li\n"},{"key":"redux-vs-context-api","content":"| date       | tag         |\n| ---------- | ----------- |\n| 2018-07-26 | React,Redux |\n\n---\n\n# 对比 Redux 和 Context API\n\n![](/static/context-vs-redux@2x.png)\n\nReact 在 16.3 版本中添加了一个新的 Context API， 「新」的意思是指之前的 Context API 是一个隐藏的功能。 由于在官方文档中并不鼓励使用 Context API， 大多数人都避免使用它，甚至都不知道它的存在。\n\n而现在 Context API 变成了 React 中的一等公民， 并且开放给了所有人(来自官方推广)。\n\nReact 16.3 一发布， 网上的很多文章就因新 Context API 的出现，宣布「Redux 已死」。 然而如果你问过 Redux，我相信它会回答你:「那些言论都是[夸大其词](https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/)」。\n\n本文将会介绍新 Context API 是如何工作的， 它与 Redux 的相似之处， 什么时候应该选用 Context，以及为什么 Context 并不能完全取代 Redux。\n\n如果你只想大致了解 Context， 可以直接[查看](#how-to-use-context-api)。\n\n## 一个简单的 React 例子\n\n现在，假设你已经清楚 React 的基础概念(props \u0026 state)， 如果你还不清楚， 这里有一个免费的五天课程可以帮助你[学习 React](https://daveceddia.com/pure-react-email-course)。\n\n让我们看一下这个大多数人会选择使用 Redux 的例子.我们首先从简单的纯 React 版本开始，再看一下如何使用 Redux，最后是 Context。\n\n![](/static/example.png)\n\n这个 app 在两处地方显示用户的信息:一个是在导航栏的右上角，一个是在主要内容左侧的侧栏。\n\n(你也许注意到了， 这看起来很像 Twitter。这并非偶然！ 磨炼 React 技术最好的方法就是[模仿](https://daveceddia.com/learn-react-with-copywork/))。\n\n组件结构如下图:\n\n![](/static/component-structure.png)\n\n如果只使用 React(普通的 props)， 需要把用户信息存在组件树中足够高的位置， 以便于把 props 向下传递到需要的组件中。在这种情况下，用户信息只能存储在`App`中。\n\n然后，为了将 props 传递到需要的组件中，App 需要把 props 先传递到 Nav 和 Body 中。 然后需要再依次向下传递，到 UserAvatar(万岁!)和 Sidebar 中。最后， SideBar 必须再向下传递到 UserStats 中。\n\n下面让我们看看如何用代码实现(我将所有的内容放到了一个文件中来增加易读性，但在真实情况下可能需要按照[某种标准结构](https://daveceddia.com/react-project-structure/)将它拆成多个独立的文件)。\n\n```Javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles.css\";\n\nconst UserAvatar = ({ user， size }) =\u003e (\n  \u003cimg\n    className={`user-avatar ${size || \"\"}`}\n    alt=\"user avatar\"\n    src={user.avatar}\n  /\u003e\n);\n\nconst UserStats = ({ user }) =\u003e (\n  \u003cdiv className=\"user-stats\"\u003e\n    \u003cdiv\u003e\n      \u003cUserAvatar user={user} /\u003e\n      {user.name}\n    \u003c/div\u003e\n    \u003cdiv className=\"stats\"\u003e\n      \u003cdiv\u003e{user.followers} Followers\u003c/div\u003e\n      \u003cdiv\u003eFollowing {user.following}\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n);\n\nconst Nav = ({ user }) =\u003e (\n  \u003cdiv className=\"nav\"\u003e\n    \u003cUserAvatar user={user} size=\"small\" /\u003e\n  \u003c/div\u003e\n);\n\nconst Content = () =\u003e \u003cdiv className=\"content\"\u003emain content here\u003c/div\u003e;\n\nconst Sidebar = ({ user }) =\u003e (\n  \u003cdiv className=\"sidebar\"\u003e\n    \u003cUserStats user={user} /\u003e\n  \u003c/div\u003e\n);\n\nconst Body = ({ user }) =\u003e (\n  \u003cdiv className=\"body\"\u003e\n    \u003cSidebar user={user} /\u003e\n    \u003cContent user={user} /\u003e\n  \u003c/div\u003e\n);\n\nclass App extends React.Component {\n  state = {\n    user: {\n      avatar:\n        \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\"，\n      name: \"Dave\"，\n      followers: 1234，\n      following: 123\n    }\n  };\n\n  render() {\n    const { user } = this.state;\n\n    return (\n      \u003cdiv className=\"app\"\u003e\n        \u003cNav user={user} /\u003e\n        \u003cBody user={user} /\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\nReactDOM.render(\u003cApp /\u003e， document.querySelector(\"#root\"));\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/q8yqx48074)\n\n在上面的代码中， `App`[初始化](https://daveceddia.com/where-initialize-state-react/)了包含 user 对象的 state， 在实际情况下，你可能需要[从服务端获取数据](https://daveceddia.com/ajax-requests-in-react/)， 并将其保存在 state 中，用于渲染。\n\n从 prop drilling 的角度来看，上面代码的问题并不严重。而且我们也绝对不会反对使用 prop drilling，它完全合理并且是 React 工作的核心方式。但是在写代码时层次过深会有一点厌烦，尤其当你需要传递多个 props 时。\n\nProp drilling 还有一个缺点就是:它使原本无关的组件之间产生了耦合。在上面的例子中，即使`Nav`并不需要`user`属性，但还是需要接收 user 属性，并且还要传递给`UserAvatar`。\n\n紧耦合的组件(将 props 转发给子组件的组件)很难重用，因为在使用这类组件时，你需要在它们的父组件中准备好这些属性。\n\n那么我们如何改进呢?\n\n## 在使用 Redux 或 Context API 之前\n\n如果你可以**合并**你的 app 结构，并且利用`childern`属性，无需借助 prop drilling， Context 或 Redux，也可以使你的代码会变得简洁。\n\n对于像`Nav`，`Sidebar`和`Body`一样，需要成为占位符的组件来说，chilren 属性是一个很好的解决方案。众所周知，你可以使用**任何**属性传递 JSX 组件，并非一定要使用 children。因此如果你需要多个入口来注入组件，请牢记这一点。\n\n这个版本的 React 示例中， `Nav`，`Body`和`Sidebar`接收 chilren 属性，并且按照他们原有的方式进行渲染。这样就不再需要担心如何传递特定的属性，只需要合理地使用组件自身的属性进行渲染即可。这个例子还展示了如何使用**任意**属性来传递 children。\n\n(感谢 Dan Abramov 提出的[建议](https://twitter.com/dan_abramov/status/1021850499618955272)!)\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles.css\";\n\nconst UserAvatar = ({ user， size }) =\u003e (\n  \u003cimg\n    className={`user-avatar ${size || \"\"}`}\n    alt=\"user avatar\"\n    src={user.avatar}\n  /\u003e\n);\n\nconst UserStats = ({ user }) =\u003e (\n  \u003cdiv className=\"user-stats\"\u003e\n    \u003cdiv\u003e\n      \u003cUserAvatar user={user} /\u003e\n      {user.name}\n    \u003c/div\u003e\n    \u003cdiv className=\"stats\"\u003e\n      \u003cdiv\u003e{user.followers} Followers\u003c/div\u003e\n      \u003cdiv\u003eFollowing {user.following}\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n);\n\n// 接收 children 并且渲染\nconst Nav = ({ children }) =\u003e (\n  \u003cdiv className=\"nav\"\u003e\n    {children}\n  \u003c/div\u003e\n);\n\nconst Content = () =\u003e (\n  \u003cdiv className=\"content\"\u003emain content here\u003c/div\u003e\n);\n\nconst Sidebar = ({ children }) =\u003e (\n  \u003cdiv className=\"sidebar\"\u003e\n    {children}\n  \u003c/div\u003e\n);\n\n// Body 需要一个 sidebar 和 content， 但用这种形式写，\n// 他们可以是任何属性\nconst Body = ({ sidebar， content }) =\u003e (\n  \u003cdiv className=\"body\"\u003e\n    \u003cSidebar\u003e{sidebar}\u003c/Sidebar\u003e\n    {content}\n  \u003c/div\u003e\n);\n\nclass App extends React.Component {\n  state = {\n    user: {\n      avatar:\n        \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\"，\n      name: \"Dave\"，\n      followers: 1234，\n      following: 123\n    }\n  };\n\n  render() {\n    const { user } = this.state;\n\n    return (\n      \u003cdiv className=\"app\"\u003e\n        \u003cNav\u003e\n          \u003cUserAvatar user={user} size=\"small\" /\u003e\n        \u003c/Nav\u003e\n        \u003cBody\n          sidebar={\u003cUserStats user={user} /\u003e}\n          content={\u003cContent /\u003e}\n        /\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\nReactDOM.render(\u003cApp /\u003e， document.querySelector(\"#root\"));\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/mj19ywz0oy)\n\n如果你的 app 十分复杂(比这个例子复杂的多!)，可能很难使用`children`的模式。下面让我们将介绍如何使用 Redux 来避免 prop drilling。\n\n## Redux 示例\n\n我们先来看一下 Redux 的示例，再仔细观察 Context 是如何工作的。如果你对 Redux 并不熟悉，可以先阅读我写的[Redux 简介](https://daveceddia.com/how-does-redux-work/)(或者[观看视频](https://youtu.be/sX3KeP7v7Kg))。\n\n将上面的 app 用 Redux 重构后，`user`信息存储在 Redux store 中。这意味着我们可以使用 react-redux 的`connect`方法直接向组件中注入`user`属性。\n\n这样就实现了组件间的解耦。 `Nav`， `Body`和`Siderbar`不再接收和传递`user`属性。再也不需要接收无用的属性，再也不存在无用的耦合。\n\n其中的 reducer 也都十分简单。我在[Redux 中的 reducers 是如何工作的](https://daveceddia.com/what-is-a-reducer/)和[如何写出 immutable 代码](https://daveceddia.com/immutable-updates-react-redux/)中对这方面知识进行了更详细的介绍。\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\n// 我们需要 createStore, connect 和 Provider:\nimport { createStore } from \"redux\";\nimport { connect, Provider } from \"react-redux\";\n\n// 创建一个带有初始空 state 的 reducer\nconst initialState = {};\nfunction reducer(state = initialState, action) {\n  switch (action.type) {\n    // 响应 the SET_USER 并更新 state\n    case \"SET_USER\":\n      return {\n        ...state,\n        user: action.user\n      };\n    default:\n      return state;\n  }\n}\n\n// 利用 reducer 创建 store\nconst store = createStore(reducer);\n\n// 派发一个 action 来设置 user 的值\n// 因为初始化的 state 是空的\nstore.dispatch({\n  type: \"SET_USER\",\n  user: {\n    avatar: \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\",\n    name: \"Dave\",\n    followers: 1234,\n    following: 123\n  }\n});\n\n// mapStateToProps 方法从 state 中抽取了一个 key（user）\n// 并用`user`属性进行传递\nconst mapStateToProps = state =\u003e ({\n  user: state.user\n});\n\n// connect() 使 UserAvatar 可以直接接收 `user`\n// 而无需从父组件中接收\n\n// 还可以分割成两个变量：\n//   const UserAvatarAtom = ({ user, size }) =\u003e ( ... )\n//   const UserAvatar = connect(mapStateToProps)(UserAvatarAtom);\nconst UserAvatar = connect(mapStateToProps)(({ user, size }) =\u003e (\n  \u003cimg\n    className={`user-avatar ${size || \"\"}`}\n    alt=\"user avatar\"\n    src={user.avatar}\n  /\u003e\n));\n\n// connect() 使 UserStats 可以直接接收`user`\n// 而无需从父组件中接收\n// 两个组件可以使用同一个 mapStateToProps 方法\nconst UserStats = connect(mapStateToProps)(({ user }) =\u003e (\n  \u003cdiv className=\"user-stats\"\u003e\n    \u003cdiv\u003e\n      \u003cUserAvatar /\u003e\n      {user.name}\n    \u003c/div\u003e\n    \u003cdiv className=\"stats\"\u003e\n      \u003cdiv\u003e{user.followers} Followers\u003c/div\u003e\n      \u003cdiv\u003eFollowing {user.following}\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n));\n\n// Nav 不再需要知道 `user`\nconst Nav = () =\u003e (\n  \u003cdiv className=\"nav\"\u003e\n    \u003cUserAvatar size=\"small\" /\u003e\n  \u003c/div\u003e\n);\n\nconst Content = () =\u003e \u003cdiv className=\"content\"\u003emain content here\u003c/div\u003e;\n\n// Sidebar 不再需要知道 `user`\nconst Sidebar = () =\u003e (\n  \u003cdiv className=\"sidebar\"\u003e\n    \u003cUserStats /\u003e\n  \u003c/div\u003e\n);\n\n// Body 不再需要知道 `user`\nconst Body = () =\u003e (\n  \u003cdiv className=\"body\"\u003e\n    \u003cSidebar /\u003e\n    \u003cContent /\u003e\n  \u003c/div\u003e\n);\n\n// App 不再维护 state， 可以简化成一个无状态的函数\nconst App = () =\u003e (\n  \u003cdiv className=\"app\"\u003e\n    \u003cNav /\u003e\n    \u003cBody /\u003e\n  \u003c/div\u003e\n);\n\n// 将整个 app 用 Provider 包起来，使 connect()\n// 能够连接到 store\nReactDOM.render(\n  \u003cProvider store={store}\u003e\n    \u003cApp /\u003e\n  \u003c/Provider\u003e,\n  document.querySelector(\"#root\")\n);\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/943yr0qp3o)\n\n现在你也许想知道 Redux 是如何实现这种魔法的。这是个好问题，为什么 React 中不支持多层传递属性，而 Redux 就可以呢？\n\n答案是 Redux 使用了 React 中的 Context 功能。不过不是新的 Context API，而是老版本 Context。 React 文档中明确说明，除非是用于第三方库或明确知道自己在做什么，否则不推荐使用 Context。\n\nContext 就像是一个运行在组件身后的总线：如果你想从中接收电力（数据），只需要插上电源就可以了（React-Redux 的 `connect()`方法）。\n\n这部分功能只是 Redux 的冰山一角。自由传递属性只是 Redux 最**表面**的功能。除此之外，Redux 还有一些其他的优点：\n\n### 「纯」的`connect`\n\n`connect` 会自动使连接的组件变成「纯组件」，这也就意味着它们只有在 props 发生变化，也就是 Redux store 中对应的值发生变化时才会重新渲染。这防止了不必要的重新渲染，保证 app 可以快速运行。DIY 方法：创建一个继承 `PureComponent` 的类，或自己实现`shouldComponentUpdate`。\n\n### Redux 可以简化调试\n\nactions 和 reducers 的样板代码带来的一个好处就是强大的调试功能。\n\n使用 [Redux DevTools Extension](https://github.com/zalmoxisus/redux-devtools-extension) 可以帮助你自动记录 app 中的每一个 action。你可以在任何时候打开它，查看触发了哪些 actions，他们的 payload 是什么，以及 action 发生前后的 state 变化。\n\n![](/static/redux-devtools.gif)\n\nRedux DevTools 的另一个重要功能是时间旅行调试，也就是说你可以通过点击已发生的 action 跳转到该时间点，也就是重播在那之前的所有 actions（包含该 action 本身）。这是由于每个 action 都是 **immutably** 更新 state，因此你可以获取到 state 更新列表，并且无副作用的随意重播。\n\n还有像 [LogRocket](https://logrocket.com/) 这种的工具，可以在每一个用户的**产品环境**上提供始终开启的 Redux DevTools。收到了 bug 报告？没问题，在 LogRocket 中查找用户的会话，你就可以看到他们的操作记录和触发的 actions。这一切都是通过挖掘 Redux 的 action 流完成的。\n\n### 自定义 Redux 中间件\n\nRedux 支持**中间件**。中间件的意思是「每次派发 action 时都会执行的方法」。实现你自己的中间件并没有看起来那么难，而且能够完成许多强大的功能。\n\n例如：\n\n- 想要在 action name 是以 `FETCH_` 为前缀时，开始 API 请求？ 你可以用中间件来实现。\n- 想要在集中地将日志发送给分析软件？中间件是个不错的解决方案。\n- 想要在特定时间内阻止某些特定 actions 触发？你可以使用中间件来实现，不会对 app 的其余部分产生影响。\n- 想要自动地拦截带有 JWT token 的 action，并把他们存到 localStorage 中？没错，中间件。\n\n这里有一篇关于[如何写 Redux 中间件](https://medium.com/@jacobp100/you-arent-using-redux-middleware-enough-94ffe991e6)的文章。\n\n## \u003ca name=\"how-to-use-context-api\"\u003e\u003c/a\u003e如何使用 Context API\n\n但是也许你不需要 Redux 中那些花哨的功能。也许你不需要简单的调试，定制化，或性能提升，你只是希望数据的传递能变得简单些。也许你的 app 很小，或者需要先让某些功能正常工作后，再考虑引入一些其他的库。\n\nReact 的新 Context API 也许很适合你。让我们看看它是如何工作的。\n\n我在 Egghead 上发布了一个简短的 Context API 课程， 如果你们更喜欢看视频，可以参考[这里](https://egghead.io/lessons/react-pass-props-through-multiple-levels-with-react-s-context-api)。\n\nContext API 中有三个重要的部分：\n\n- `React.createContext` 生成 Context。\n- `Provider`（由`createContext`返回）创建贯穿整个组件树的「总线」。\n- `Consumer`（也是由`createContext`生成，接通「总线」以获取数据。\n\n这里的`Provider`和 React-Redux 里的`Provider`很像。接收任何形式的`value`属性（也可以是 Redux store，但是这样做很蠢）。大多数情况下都是包含一些数据和操作这些数据的方法的对象。\n\n而`Consumer`和 React-Redux 的`connect`方法有点像，接通数据并提供给组件。\n\n接下来是重点：\n\n```javascript\n// 首先，我们生成一个新的 Context\n// 这是一个包含了两个属性的对象: { Provider, Consumer }\n// 切记命名方式是帕斯卡式而不是驼峰式\n// 这十分重要，因为我们一会要把它用作一个组件\n// 组件名必须要以大写字母开始\nconst UserContext = React.createContext();\n\n// 需要数据的组件使用 Consumer 属性接通 context\n// Consumer 使用「render props」模式。\nconst UserAvatar = ({ size }) =\u003e (\n  \u003cUserContext.Consumer\u003e\n    {user =\u003e (\n      \u003cimg\n        className={`user-avatar ${size || \"\"}`}\n        alt=\"user avatar\"\n        src={user.avatar}\n      /\u003e\n    )}\n  \u003c/UserContext.Consumer\u003e\n);\n\n// 注意，我们不再是需要 user 属性\n// 因为 Consumer 可以从 context 中直接获取\nconst UserStats = () =\u003e (\n  \u003cUserContext.Consumer\u003e\n    {user =\u003e (\n      \u003cdiv className=\"user-stats\"\u003e\n        \u003cdiv\u003e\n          \u003cUserAvatar user={user} /\u003e\n          {user.name}\n        \u003c/div\u003e\n        \u003cdiv className=\"stats\"\u003e\n          \u003cdiv\u003e{user.followers} Followers\u003c/div\u003e\n          \u003cdiv\u003eFollowing {user.following}\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    )}\n  \u003c/UserContext.Consumer\u003e\n);\n\n// ... 其他组件 ...\n// ... 不在需要关注 `user` 属性\n\n// 最后，在 App 中，我们利用 Provider\n// 向下传递 context\nclass App extends React.Component\n  state = {\n    user: {\n      avatar:\n        \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\",\n      name: \"Dave\",\n      followers: 1234,\n      following: 123\n    }\n  };\n\n  render() {\n    return (\n      \u003cdiv className=\"app\"\u003e\n        \u003cUserContext.Provider value={this.state.user}\u003e\n          \u003cNav /\u003e\n          \u003cBody /\u003e\n        \u003c/UserContext.Provider\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/q9w2qrw6q4)\n\n让我们回顾一下它是如何工作的。\n\n记住一共三个部分： context 自身（由 `React.createContext` 创建），还有两个组件（`Provider` 和 `Consumer`）。\n\n### Provider 和 Consumer 是对应的\n\nProvider 和 Consumer 是绑定在一起的，不可分割。而且它们只知道如何与**对方**通信。如果你创建了两个不同的 contexts， 「Context1」和「Context2」，则 Context1 的 Provider 和 Consumer 无法与 Context2 的 Provider 和 Consumer 通信。\n\n### Context 不存储状态\n\n注意，context 自身**并没有自身的 state**。 它仅仅是数据的管道，向`Provider`中传入数据，传递到对应的`Consumer`中。\n\n当你在创建 context 时，可以像这样的传人「默认值」：\n\n```javascript\nconst Ctx = React.createContext(yourDefaultValue);\n```\n\n当 `Consumer` 上方没有 `Provider` 时，会使用默认值。如果不传的话， 默认值就是 `undefined`。 切记，这是**默认值**， 不是**初始**值。context 不保留任何值，只是传递你输入的数据。\n\n### Consumer 使用 Render Props 模式\n\nRedux 的 `connect` 是一个高阶组件（HoC），**封装**另一个组件，并且将值传递给它。\n\n相反的是，context 中的 `Consumer` 期望它的子组件是一个函数。 它在渲染时调用该函数，将从上层 `Provider` 中获取的值（或者是 context 的默认值，或者是 `undefined`）传进去。\n\n### Provider 只接收一个值\n\nProvider 只接收 `value` 属性。但传入的值可以是任何类型的。 如果你想传递多个值，你可以创建一个包含多个值的对象，并把该**对象**传递下去。\n\n以上就是 Context API 的大致内容了。\n\n## Context API 十分灵活\n\n因为创建 Context 会为我们提供两个可供自由使用的组件（Provier 和 Consumer）。下面是一些想法：\n\n### 将 Consumer 转化成高阶组件\n\n不想在每次使用时都添加 `UserContext.Consumer`？当然可以，这是你自己的代码！你已经成年了。\n\n如果你更喜欢通过属性的方式接收数据，可以对 `Consumer` 进行简单的封装，像这样：\n\n```javascript\nfunction withUser(Component) {\n  return function ConnectedComponent(props) {\n    return (\n      \u003cUserContext.Consumer\u003e\n        {user =\u003e \u003cComponent {...props} user={user} /\u003e}\n      \u003c/UserContext.Consumer\u003e\n    );\n  };\n}\n```\n\n还可以用 `withUser` 重写 `UserAvatar`：\n\n```javascript\nconst UserAvatar = withUser(({ size, user }) =\u003e (\n  \u003cimg\n    className={`user-avatar ${size || \"\"}`}\n    alt=\"user avatar\"\n    src={user.avatar}\n  /\u003e\n));\n```\n\nBOOM! 你可以像使用 Redux 的 `connect` 一样使用 context, 但是无法将组件自动变成「纯组件」。\n\n### 在 Provider 中维护 state\n\n还记得么， context 中的 Provider 只是一个传递数据的管道，无法维护任何数据。但你可以自己封装 Provider，来维护数据。\n\n在上面的例子中，我将数据都存储在 `App` 中，是为了帮助你更好地理解 Provider 和 Consumer。但是也许你想用生成一个自己的「store」。你可以自己创建一个维护和传递数据的组件：\n\n```javascript\nclass UserStore extends React.Component {\n  state = {\n    user: {\n      avatar:\n        \"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b\",\n      name: \"Dave\",\n      followers: 1234,\n      following: 123\n    }\n  };\n\n  render() {\n    return (\n      \u003cUserContext.Provider value={this.state.user}\u003e\n        {this.props.children}\n      \u003c/UserContext.Provider\u003e\n    );\n  }\n}\n\n// ... 跳过中间部分 ...\n\nconst App = () =\u003e (\n  \u003cdiv className=\"app\"\u003e\n    \u003cNav /\u003e\n    \u003cBody /\u003e\n  \u003c/div\u003e\n);\n\nReactDOM.render(\n  \u003cUserStore\u003e\n    \u003cApp /\u003e\n  \u003c/UserStore\u003e,\n  document.querySelector(\"#root\")\n);\n```\n\n现在 `UserStore` 唯一的职责就是维护 user 数据。太棒了， `App` 现在又是无状态组件，而且看起来更整洁了。\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/jpy76nm1v)\n\n### 使用 Context 传递 Actions\n\n通过 `Provider` 向下传递的对象中可以包含任何类型的数据，当然也就包括函数。你也可以叫「actions」。\n\n下面是一个简单的例子：一个简单的房间，还有一个开关来切换背景颜色-对不起，我是指灯光。\n\n![](/static/lightswitch-app.gif)\n\nstore 中不但包含灯光状态，还包含了切换灯光状态的函数，并且都将使用 context 向下传递。\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles.css\";\n\n// 空的 context\nconst RoomContext = React.createContext();\n\n// 本组件的唯一的职责：管理 Room 状态的组件\nclass RoomStore extends React.Component {\n  state = {\n    isLit: false\n  };\n\n  toggleLight = () =\u003e {\n    this.setState(state =\u003e ({ isLit: !state.isLit }));\n  };\n\n  render() {\n    // 向下传递 state 和 onToggleLight\n    return (\n      \u003cRoomContext.Provider\n        value={{\n          isLit: this.state.isLit,\n          onToggleLight: this.toggleLight\n        }}\n      \u003e\n        {this.props.children}\n      \u003c/RoomContext.Provider\u003e\n    );\n  }\n}\n\n// 从 RoomContext 接收 state 和控制函数\nconst Room = () =\u003e (\n  \u003cRoomContext.Consumer\u003e\n    {({ isLit, onToggleLight }) =\u003e (\n      \u003cdiv className={`room ${isLit ? \"lit\" : \"dark\"}`}\u003e\n        The room is {isLit ? \"lit\" : \"dark\"}.\u003cbr /\u003e\n        \u003cbutton onClick={onToggleLight}\u003eFlip\u003c/button\u003e\n      \u003c/div\u003e\n    )}\n  \u003c/RoomContext.Consumer\u003e\n);\n\nconst App = () =\u003e (\n  \u003cdiv className=\"app\"\u003e\n    \u003cRoom /\u003e\n  \u003c/div\u003e\n);\n\n// 将整个 App 包装在 RoomStore 中\n// 在 `App` 中包装也可以\nReactDOM.render(\n  \u003cRoomStore\u003e\n    \u003cApp /\u003e\n  \u003c/RoomStore\u003e,\n  document.querySelector(\"#root\")\n);\n```\n\n[CodeSandbox 上的示例。](https://codesandbox.io/s/jvky9o0nvw)\n\n## 应该选择 Context 还是 Redux 呢\n\n现在你已经了解了它们的工作方式，你应该选择哪一个？**想清楚后再做决定**可以使你的 app 变得更好，写起来更有趣。我知道你也许只想要一个确定的「答案」，但我很遗憾的告诉你，「要视情况而定」。\n\n这依赖于 app 的大小，或将来的大小。将会有多少人进行开发 - 只有你，还是一个更大的团队？你或你的团队对于函数式的概念（Redux 依赖于此，像 immutability 和纯函数等）掌握如何？\n\n现在 JavaScript 生态系统中弥漫着一股竞争的气息，这是十分错误而且有害的。好像每一个选择都是零和博弈：如果你使用了**库 A**，那么你一定不能使用**它的竞争对手库 B**。当一个新的库发布时，一定在某种程度上比现有的库会更好一些，而且会将其取代。感觉所有的事情都是二选一，要么选择最好的，要么和过去的开发者一起退居幕后。\n\n将一系列选择看做工具箱会是一个更好的方案。像是选择用螺丝刀还是冲击起子。对于 80%的工作来说，冲击起子可以更快地固定螺丝。但对于另外的 20%，也许因为空间太小，或物品十分精致等原因，其实螺丝刀是一个更好的选择。当我得到冲击起子时，我不会立即丢弃螺丝刀，还有我的电钻。冲击起子无法**取代**其他的工具，它只是为我提供了另一个选项，另一个解决问题的方式。\n\nContext 完全不会「取代」Redux，就像 React 无法「取代」 Angular 或 jQuery。当我需要很快完成一些事情时，我还是会使用 jQuery。我有时还会使用服务器端渲染的 EJS 模板而不是启动一个完整的 React app。有时你的任务完全不需要 React 或 Redux 来完成。\n\n如今，当 Redux 的功能超过了你所需要的， 你可以选择 Context。\n\n- 原文地址：https://daveceddia.com/context-api-vs-redux/#how-to-use-the-react-context-api\n- 译文出自：TWNTF\n- 译者：Yingjian Li\n"},{"key":"react-native-at-airbnb-3","content":"| date       | tag          |\n| ---------- | ------------ |\n| 2018-07-25 | React-Native |\n\n---\n\n# [翻译]Airbnb 的 React Native 实践： 构建一个跨平台的移动端团队\n\n\u003e React Native 转型\n\n_这是 Airbnb 关于 React Native 经验分享和移动端未来计划系列文章的第三篇._\n\n除了数不尽的技术上的利弊, 我们还了解到 React Native 对工程团队的意义. 这远比向当前平台中添加一个新库或模式要复杂的多,我们在期间遭遇了许多组织上的挑战.与技术上的挑战不同,组织上的挑战更难发现,解决,恢复.谢天谢地,我们的 mobile 文化十分健全,但下面是在团队中使用 React Native 时需要注意的一些事项.\n\n### 两极分化的 React Native\n\n根据我们的经验, 工程师们关于 React Native 有着完全不同的看法,有人认为它是统一了 Android,iOS 和 web 的银弹,有人则完全反对在团队中使用 React Native.即使是在使用之后,情况也十分类似,有的团队认为它是极好的,而有的人却感到失望并重新使用 native.\n\n### 追踪根本原因\n\n在使用 React Native 时会有许多不可避免的 bug,改进和性能问题.但也还有许多不断变化的部分:\n\n1.  React Native 自身变化十分迅速\n2.  基础设施和功能的开发是同时进行的\n3.  React Native 对所有人来说都是一门新的技术,需要大家一起学习\n4.  我们的文档与调试指引有时会不一致,产生困惑\n\n因此,想要找到问题的根本原始通常是很困难的.有时无法确定问题是由哪个团队引起的还是 React Native 自身导致的.\n\n### React Native 仍然需要 native\n\n一个常见的误解就是 React Native 可以使你完全不用写原生代码.然而事实并非如此,有时你仍然需要写原生代码.例如,文本在不同平台上的渲染会有细微的差别,键盘的处理也有所不同以及在 Android 上 Activity 的重新创建和旋转等. 高质量的 React Native 应用需要仔细地平衡所有平台. 而三个平台间专业知识的平衡又十分困难,就导致了很难产出一个高质量的应用.\n\n### 跨平台调试\n\n大多数的工程师都精通一到两个平台.同时精通 Android,iOS 和 React 的人少之又少.即使绝大部分的工作都是在成熟的 React Native 环境下完成的,有时也需要在深层的 native 层构建或调试.这样工程师们就会在一个自己从来没用过的平台中 debug.而且由于问题的根本原因很难被定位,工程师会无从下手.\n\n### 招聘\n\n即使我们采用了 React Native,我们的 mobile 团队也在不断发展壮大.但是在社区中,许多人开始把 Airbnb 和 React Native 关联了起来,而且有些甚至认为我们的 App 是纯的 React Native App,但事实并非如此.结果许多 Android 和 iOS 工程师会犹豫是否要选择 Airbnb,我们仍然在[招聘](https://www.airbnb.com/careers/departments/engineering)!\n\n### 艰难的 Hybrid App\n\n只用 React Native 或 native 开发应用是相对简单的.但是,一旦你选择了混合开发,你就会发现很多问题.如何划分团队?团队间如何协作?如何跨应用共享状态?如何保证测试?如何有效地跨平台调试?如何决定哪个平台使用新功能?如何雇佣和分配资源?这些都是不可避免而且很难解决的问题.\n\n### 三种开发环境\n\n如果想要高效地开发 React Native,必须要有稳定的,最新的 React Native, Android 和 iOS 环境.对于像 Airbnb 这样体量的公司来说,每个平台都需要大量的时间来配置,学习和更新.几个星期后回来通常意味着你需要花几个小时让一切恢复到最新状态.\n\n### React Native 和 native 之间的平衡\n\n在很多情况下,解决问题的最佳方案都需要横跨 React Native 和 native.例如,我们导航栏的实现大量的使用 Activities 和 ViewControllers,大部分的代码都是各自平台上的 native 代码.很多时候都不清楚究竟是该写 React Native 代码还是 native 代码.而工程师自然会选择他们熟悉的平台,这就会产生一些不理想的代码.\n\n### 跨平台测试\n\n我们发现工程师们会主要开发他们熟悉的平台,而且认为如果在他们测试的平台上是好的,在其他平台上也是一样.受益于 React Native 的特性,大多数情况下确实是这样的.但是有些时候会在 QA 环境或产品环境中出现问题.\n\n### 团队划分\n\n同时使用 React Native 和 native 的团队会同时面对技术问题和沟通问题.一旦把代码库按照 native 和 React Native 划分开,代码会变得碎片化.共享业务逻辑,模型,状态等变得更加困难而且工程师不会再有整个工作流程的开发经验.我们从最开始就清楚这一点,但考虑到如果能够更多的和 web 端协作,情况可能会有好转.一些团队之间开始在 web 和 mobile 之间分享资源和代码,但效果并不明显.\n\n### 感观的迭代速度\n\n使用 React Native 的一个主要目标就是提高开发速度.通常情况下,React Native 的功能是由单个工程师完成的.从 React Native 工程师的角度来看,如果他花费了超过 Android 或 iOS 上开发时间的 50%的时间,即使整体花费的时间更少,他们也会觉得更长.\n\n### 公共资源和文档\n\nAndroid 和 iOS 已有 10 年历史,而且有数百万的工程师贡献于学习资源,开源和在线帮助.我们利用如[CodePath](https://codepath.com/androidbootcamp)等资源帮助人们学习 Android 和 iOS.即使 React Native 拥有最大的跨平台社区之一,而且可以利用 React 的资源,但仍比 Android 和 iOS 小得多.再加上我们必须内部构建大部分基础设施,这意味着相对于 native,我们把有限的 React Native 资源过度地投资在教育和训练.\n\n---\n\n_这是 Airbnb 关于 React Native 经验分享和移动端未来计划系列文章的第三篇._\n\n[第一篇: React Native at Airbnb](../react-native-at-airbnb-1)\n\n[第二篇: The Technology](../react-native-at-airbnb-2)\n\n[第三篇: Building a Cross-Platform Mobile Team](../react-native-at-airbnb-3)\n\n[第四篇: Making a Decision on React Native](../react-native-at-airbnb-4)\n\n[第五篇: What's Next for Mobile](../react-native-at-airbnb-5)\n\n- 原文地址：https://medium.com/airbnb-engineering/building-a-cross-platform-mobile-team-3e1837b40a88\n- 译文出自：TWNTF\n- 译者：Yingjian Li\n"}],"filteredPosts":[{"key":"goodbye-redux","title":"[翻译]再见了, Redux","tag":["Redux"],"date":"2018-09-18"},{"key":"react-native-at-airbnb-4","title":"[翻译]Airbnb 的 React Native 实践： 弃用 React Native","tag":["React-Native"],"date":"2018-08-14"},{"key":"react-native-at-airbnb-5","title":"[翻译]Airbnb 的 React Native 实践： 移动端发展计划","tag":["React-Native"],"date":"2018-08-11"},{"key":"redux-vs-context-api","title":"对比 Redux 和 Context API","tag":["React","Redux"],"date":"2018-07-26"},{"key":"react-native-at-airbnb-3","title":"[翻译]Airbnb 的 React Native 实践： 构建一个跨平台的移动端团队","tag":["React-Native"],"date":"2018-07-25"},{"key":"react-native-at-airbnb-2","title":"[翻译]Airbnb 的 React Native 实践： 技术细节","tag":["React-Native"],"date":"2018-07-19"},{"key":"react-native-at-airbnb-1","title":"[翻译]Airbnb 的 React Native 实践： 概述","tag":["React-Native"],"date":"2018-07-18"}]}},"page":"/page","pathname":"/page","query":{"cur":1,"pageCount":2},"buildId":"_C0lHUbZafnHm5wwQ5b9U","assetPrefix":"/next-blog","runtimeConfig":{"backendUrl":"/next-blog"},"nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/page" src="/next-blog/_next/static/_C0lHUbZafnHm5wwQ5b9U/pages/page.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/next-blog/_next/static/_C0lHUbZafnHm5wwQ5b9U/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/next-blog/_next/static/_C0lHUbZafnHm5wwQ5b9U/pages/_error.js"></script><script src="/next-blog/_next/static/runtime/webpack-bf0647fcc5634d05e2c1.js" async=""></script><script src="/next-blog/_next/static/chunks/commons.fe83b0699cc115d8f2f1.js" async=""></script><script src="/next-blog/_next/static/runtime/main-8c21d63e457d27dcf8e4.js" async=""></script></body></html>